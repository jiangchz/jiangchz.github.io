<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.lug.ustc.edu.cn/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content=",,,," />





  <link rel="alternate" href="/atom.xml" title="小土刀" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="这篇文章主要介绍计算机网络的相关知识，因为网络的重要组成不是是协议，所以很大篇幅会是相关协议以及具体的应用。整体的结构基于 Vamei 博客中的结构（以及一些配图），加上自己在网络上搜集和日常学习中的一些思考，整理成为本文。">
<meta name="keywords">
<meta property="og:type" content="website">
<meta property="og:title" content="计算机网络">
<meta property="og:url" content="http://wdxtub.com/vault/internet-protocol.html">
<meta property="og:site_name" content="小土刀">
<meta property="og:description" content="这篇文章主要介绍计算机网络的相关知识，因为网络的重要组成不是是协议，所以很大篇幅会是相关协议以及具体的应用。整体的结构基于 Vamei 博客中的结构（以及一些配图），加上自己在网络上搜集和日常学习中的一些思考，整理成为本文。">
<meta property="og:image" content="http://wdxtub.com/images/14551385707784.jpg">
<meta property="og:image" content="http://wdxtub.com/images/14551392855125.jpg">
<meta property="og:image" content="http://wdxtub.com/images/14551393750144.jpg">
<meta property="og:image" content="http://wdxtub.com/images/14551393925085.jpg">
<meta property="og:image" content="http://wdxtub.com/images/14551394092221.jpg">
<meta property="og:image" content="http://wdxtub.com/images/14551394375473.jpg">
<meta property="og:image" content="http://wdxtub.com/images/14551394884094.jpg">
<meta property="og:image" content="http://wdxtub.com/images/14551395013280.jpg">
<meta property="og:image" content="http://wdxtub.com/images/14551395178688.jpg">
<meta property="og:image" content="http://wdxtub.com/images/14551395342559.jpg">
<meta property="og:image" content="http://wdxtub.com/images/14551395682155.jpg">
<meta property="og:image" content="http://wdxtub.com/images/14551395777596.jpg">
<meta property="og:image" content="http://wdxtub.com/images/14551395892901.jpg">
<meta property="og:image" content="http://wdxtub.com/images/14551396019064.jpg">
<meta property="og:image" content="http://wdxtub.com/images/14551396186893.jpg">
<meta property="og:image" content="http://wdxtub.com/images/14551396313267.jpg">
<meta property="og:image" content="http://wdxtub.com/images/14551396446583.jpg">
<meta property="og:image" content="http://wdxtub.com/images/14551396560030.jpg">
<meta property="og:image" content="http://wdxtub.com/images/14551396675029.jpg">
<meta property="og:image" content="http://wdxtub.com/images/14551396849165.jpg">
<meta property="og:image" content="http://wdxtub.com/images/14551396962662.jpg">
<meta property="og:image" content="http://wdxtub.com/images/14551397079720.jpg">
<meta property="og:image" content="http://wdxtub.com/images/14551397204458.jpg">
<meta property="og:updated_time" content="2016-02-11T14:03:07.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="计算机网络">
<meta name="twitter:description" content="这篇文章主要介绍计算机网络的相关知识，因为网络的重要组成不是是协议，所以很大篇幅会是相关协议以及具体的应用。整体的结构基于 Vamei 博客中的结构（以及一些配图），加上自己在网络上搜集和日常学习中的一些思考，整理成为本文。">
<meta name="twitter:image" content="http://wdxtub.com/images/14551385707784.jpg">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 4016951,
      author: '博主'
    }
  };
</script>

  <title>
  

  
    计算机网络 | 小土刀
  
</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <!-- hexo-inject:begin --><!-- hexo-inject:end --><script type="text/javascript">
    (function() {
      var hm = document.createElement("script");
      hm.src = "//tajs.qq.com/stats?sId=59042340";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <div style="display: none;">
    <script src="http://s6.cnzz.com/stat.php?id=1260625611&web_id=1260625611" type="text/javascript"></script>
  </div>





  
  
    
  

  <div class="container one-collumn sidebar-position-left  ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">小土刀</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Agony is my triumph</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-work">
          <a href="/2016/09/11/work-page" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-pencil"></i> <br />
            
            作品
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tech">
          <a href="/2009/09/11/tech-page" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-battery-full"></i> <br />
            
            技术
          </a>
        </li>
      
        
        <li class="menu-item menu-item-life">
          <a href="/1990/09/11/life-page" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-bolt"></i> <br />
            
            生活
          </a>
        </li>
      
        
        <li class="menu-item menu-item-booklist">
          <a href="/1997/09/11/booklist-page" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-diamond"></i> <br />
            
            书单
          </a>
        </li>
      
        
        <li class="menu-item menu-item-thanks">
          <a href="/thanks" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-gift"></i> <br />
            
            关于我
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="#" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    
    
      <p>这篇文章主要介绍计算机网络的相关知识，因为网络的重要组成不是是协议，所以很大篇幅会是相关协议以及具体的应用。整体的结构基于 <a href="http://www.cnblogs.com/vamei/" target="_blank" rel="external">Vamei</a> 博客中的结构（以及一些配图），加上自己在网络上搜集和日常学习中的一些思考，整理成为本文。</p>
<a id="more"></a>
<hr>
<h2 id="分层模型"><a href="#分层模型" class="headerlink" title="分层模型"></a>分层模型</h2><p>首先需要明确的就是，网络通信是基于分层模型的。虽然不同的协议有不同的层级划分（甚至同一种协议也有不同的层级划分），但是都离不开分层。分层的好处有很多，最重要的是能够比较好控制具体实现的复杂度，由于每层之间由事先约定的接口通信，所以其实并不需要在意每层的具体实现。</p>
<p>比较出名的分层模型有 OSI 分层模型和 TCP/IP 分层模型，它们的对应关系如下：</p>
<p><img src="/images/14551385707784.jpg" alt=""></p>
<p>OSI 分层模型将计算机网络体系结构的通信协议划分为七层，自下而上依次为：物理层（Physics Layer）、数据链路层（Data Link Layer）、网络层（Network Layer）、传输层（Transport Layer）、会话层（Session Layer）、表示层（Presentation Layer）、应用层（Application Layer）。其中第四层完成数据传送服务，上面三层面向用户。</p>
<p><strong>物理层(physical layer)</strong></p>
<p>所谓的物理层，是指光纤、电缆或者电磁波等真实存在的物理媒介。这些媒介可以传送物理信号，比如亮度、电压或者振幅。对于数字应用来说，我们只需要两种物理信号来分别表示0和1，比如用高电压表示1，低电压表示0，就构成了简单的物理层协议。针对某种媒介，电脑可以有相应的接口，用来接收物理信号，并解读成为0/1序列。</p>
<p><strong>连接层(link layer)</strong></p>
<p>在连接层，信息以帧(frame)为单位传输。所谓的帧，是一段有限的0/1序列。连接层协议的功能就是识别0/1序列中所包含的帧。比如说，根据一定的0/1组合识别出帧的起始和结束。在帧中，有收信地址(Source, SRC)和送信地址(Destination, DST)，还有能够探测错误的校验序列(Frame Check Sequence)。当然，帧中最重要的最重要是所要传输的数据 (payload)。这些数据往往符合更高层协议，供网络的上层使用。与数据相配套，帧中也有数据的类型(Type)信息。连接层协议不关心数据中到底包含什么。帧就像是一个信封，把数据包裹起来。</p>
<p>以太网(Ethernet)和WiFi是现在最常见的连接层协议。通过连接层协议，我们可以建立局域的以太网或者WiFi局域网，并让位于同一局域网络中的两台计算机通信。</p>
<p><strong>网络层(network layer)</strong></p>
<p>如何让WiFi上的一台计算机和以太网上的另一台计算机通信呢？我们需要一个“中间人”。这个“中间人”必须有以下功能: </p>
<ol>
<li>能从物理层上在两个网络的接收和发送0/1序列</li>
<li>能同时理解两种网络的帧格式</li>
</ol>
<p>路由器(router)就是为此而产生的“翻译”。一个路由器有多个网卡(NIC，Network Interface Controller)，每个NIC可以接入多个网络，并理解相应的连接层协议。在帧经过路由到达另一个网络的时候，路由会读取帧的信息，并改写以发送到另一个网络。</p>
<p>整个通信过程如下:</p>
<p>WiFi上的计算机1 -&gt; 路由WiFi接口 -&gt;  路由以太网接口 -&gt; 以太网上的计算机2</p>
<p>在连接层，我们的一个帧中只能记录SRC和DST两个地址。而上面的过程需要经过四个地址 (计算机1，WiFi接口，以太网接口，计算机2)。显然，仅仅靠连接层协议无法满足我们的需要。由于连接层协议开发在先，我们无法改动连接层协议，只能在连接层的数据(payload)下功夫了，IP协议应运而生。</p>
<p><strong>传输层(transport layer)</strong></p>
<p>上面的三层协议让不同的计算机之间可以通信。但计算机中实际上有许多个进程，每个进程都可能有通信的需求(参看Linux进程基础和Linux进程间通信)。</p>
<p>传输层协议，比如TCP和UDP，使用端口号(port number)来识某个进程。在传输数据的时候，我们写上目的进程的端口。当数据到达另一台计算机时，会根据传输层协议，识别端口号，将信送给不同的进程。</p>
<p>TCP和UDP协议是两种不同的传输层协议。UDP 协议比较简单，但是不太可靠；TCP 协议有着相对复杂的握手机制，比较可靠。TCP协议还有控制网络交通等功能。</p>
<p><strong>应用层(application layer)</strong></p>
<p>通过上面的几层协议，我们已经可以在任意两个进程之间进行通信。应用层协议是对数据内容·进一步的用语规范。应用层的协议包括用于Web浏览的HTTP协议，用于传输文件的FTP协议，用于Email的IMAP等等。</p>
<h2 id="连接层协议"><a href="#连接层协议" class="headerlink" title="连接层协议"></a>连接层协议</h2><p>以太网和WiFi是连接层的两种协议。在连接层，信息以帧(frame)为单位传输。帧像信封一样将数据(payload)包裹起来，并注明收信地址和送信地址。我们先来看看以太网的帧。</p>
<p><strong>以太网的帧格式</strong></p>
<p>帧本身是一段有限的0/1序列。它可以分为 <code>头部 | 数据(Payload) | 尾部</code> 三部分:</p>
<pre><code>Preamble SFD DST SRC Type | Payload(Data) | Pad FCS Extension
</code></pre><p>帧按照上面的顺序从头到尾依次被发送/接收。我们下面进一步解释各个区域。</p>
<p><strong>头部</strong></p>
<p>帧的最初 7 个 byte 被称为序言(preamble)。它的每个byte都是0xAA(这里是十六进制，也就是二进制的10101010)。通常，我们都会预定好以一定的频率发送0/1序列(比如每秒10bit)。如果接收设备以其他频率接收(比如每秒5bit)，那么就会错漏掉应该接收的0/1信息。但是，由于网卡的不同，发送方和接收方即使预订的频率相同，两者也可能由于物理原因发生偏差。这就好像两个人约好的10点见，结果一个人表快，一个人表慢一样。序言是为了让接收设备调整接收频率，以便与发送设备的频率一致，这个过程就叫做时钟复原(recover the clock)。</p>
<p>时钟调整好之后，我们等待帧的起始信号(SFD, start frame delimiter)。SFD是固定的值0xAB。</p>
<p>紧随SFD之后的是 6 byte的目的地(DST, destination)和 6 byte的发出地(SRC, source)。这里写的是对地址的“本地描述”，也就是MAC地址。MAC地址是物理设备自带的序号，只能在同一个以太网中被识别。</p>
<p>头部的最后一个区域是Type，用以说明数据部分的类型。(比如0x0800为IPv4，0x0806为ARP)</p>
<p><strong>数据</strong></p>
<p>数据一般包含有符合更高层协议的数据，比如IP包。连接层协议本身并不在乎数据是什么，它只负责传输。注意，数据尾部可能填充有一串0(PAD区域)。原因是数据需要超过一定的最小长度。</p>
<p><strong>尾部</strong></p>
<p>跟随在数据之后的是校验序列(FCS, Frame Check Sequence)。校验序列是为了检验数据的传输是否发生错误。</p>
<p>一个方法是将数据发送两遍，然后对比一下是否一样。但这样就大大降低了网络的效率。FCS采用了CRC(Cyclic Redundancy Check)算法。CRC 算法也相类似。n 位 CRC 算法取一个 n bit 的因子，比如下面的 1011。数据序列结尾增加 n-1 个 0。因子与数据序列的不断进行 XOR 运算，直到得到n-1位的余数，也就是100。该余数各位取反(011)，然后存储在FCS的位置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">11010011101100 000 &lt;--- 数据序列末尾增加3位0</div><div class="line">1011               &lt;--- 因子</div><div class="line">01100011101100 000 &lt;--- XOR结果</div><div class="line"> 1011              &lt;--- 因子</div><div class="line">00111011101100 000</div><div class="line">  1011</div><div class="line">00010111101100 000</div><div class="line">   1011</div><div class="line">00000001101100 000</div><div class="line">       1011</div><div class="line">00000000110100 000</div><div class="line">        1011</div><div class="line">00000000011000 000</div><div class="line">         1011</div><div class="line">00000000001110 000</div><div class="line">          1011</div><div class="line">00000000000101 000 </div><div class="line">           101 1</div><div class="line">-----------------</div><div class="line">00000000000000 100 &lt;--- 3位余数</div></pre></td></tr></table></figure>
<p>上面例子用的是4位CRC。在Ethernet中使用的因子为32位的，以达到更好的检测效果。</p>
<p><strong>集线器(Hub) vs. 交换器(Switch)</strong></p>
<p>以太网使用集线器或者交换器将帧从发出地传送到目的地。一台集线器或交换器上有多个端口，每个端口都可以连接一台计算机(或其他设备)。</p>
<p>集线器像一个广播电台。一台电脑将帧发送到集线器，集线器会将帧转发到所有其他的端口。每台计算机检查自己的MAC地址是不是符合DST。如果不是，则保持沉默。集线器是比较早期的以太网设备。它有明显的缺陷：</p>
<ol>
<li>任意两台电脑的通信在同一个以太网上是公开的。所有连接在同一个集线器上的设备都能收听到别人在传输什么，这样很不安全。可以通过对信息加密提高安全性。</li>
<li>不允许多路同时通信。如果两台电脑同时向集线器发信，集线器会向所有设备发出“冲突”信息，提醒发生冲突。可以在设备上增加冲突检测算法(collision detection)：一旦设备发现有冲突，则随机等待一段时间再重新发送。</li>
</ol>
<p>交换器克服集线器的缺陷。交换器记录有各个设备的MAC地址。当帧发送到交换器时，交换器会检查DST，然后将帧只发送到对应端口。交换器允许多路同时通信。由于交换器的优越性，交换器基本上取代了集线器。但比较老的以太网还有可能在使用集线器。</p>
<p><strong>WiFi</strong></p>
<p>WiFi的工作方式与集线器连接下的以太网类似。一个WiFi设备会向所有的WiFi设备发送帧，其它的WiFi设备检查自己是否符合DST。由于WiFi采取无线电信号，所以很难像交换器一样定向发送，所以WiFi的安全性很值得关注。WiFi采用加密的方法来实现信息的安全性。</p>
<p>(早期的WEP加密方法非常脆弱，建议使用WPA或者WPA2加密方法。隐藏WiFi设备ID的方法不是很有用。)</p>
<h2 id="网络层协议"><a href="#网络层协议" class="headerlink" title="网络层协议"></a>网络层协议</h2><p>网络层(network layer)是实现互联网的最重要的一层。正是在网络层面上，各个局域网根据 IP 协议相互连接，最终构成覆盖全球的 Internet。更高层的协议，无论是 TCP 还是 UDP，必须通过网络层的 IP 数据包(datagram)来传递信息。操作系统也会提供该层的 socket，从而允许用户直接操作 IP 包。</p>
<p>IP 数据包是符合 IP 协议的信息(也就是0/1序列)，我们后面简称 IP 数据包为 IP 包。IP 包分为头部(header)和数据(Data)两部分。数据部分是要传送的信息，头部是为了能够实现传输而附加的信息。</p>
<p>IP 协议可以分为 IPv4 和 IPv6 两种。IPv6 是改进版本，用于在未来取代 IPv4 协议。下面是 IPv4的格式</p>
<p><img src="/images/14551392855125.jpg" alt=""></p>
<p>与帧类似，IP 包的头部也有多个区域。我们将注意力放在红色的发出地(source address)和目的地(destination address)。它们都是IP地址。IPv4 的地址为 4 bytes的长度(也就是32位)。我们通常将 IPv4 的地址分为四个十进制的数，每个数的范围为 0-255,比如 192.0.0.1 就是一个 IP 地址。填写在 IP 包头部的是该地址的二进制形式。</p>
<p>IP地址是全球地址，它可以识别局域网和主机。这是通过将IP地址分类实现的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">IP class    From          To                Subnet Mask</div><div class="line">A           1.0.0.0       126.255.255.255    255.0.0.0</div><div class="line">B           128.0.0.0     191.255.255.255    255.255.0.0</div><div class="line">C           192.0.0.0     223.255.255.255    255.255.255.0</div></pre></td></tr></table></figure>
<p>每个 IP 地址的 32 位分为前后两部分，第一部分用来区分局域网，第二个部分用来区分该局域网的主机。子网掩码(Subnet Mask)告诉我们这两部分的分界线，比如 255.0.0.0 (也就是8个1和24个0)表示前 8 位用于区分局域网，后 24 位用于区分主机。由于 A、B、C 分类是已经规定好的，所以当一个IP地址属于 B 类范围时，我们就知道它的前 16 位和后 16 位分别表示局域网和主机。</p>
<p><strong>网卡与路由器</strong></p>
<p>IP地址实际上识别的是网卡(NIC, Network Interface Card)。网卡是计算机的一个硬件，它在接收到网路信息之后，将信息交给计算机(处理器/内存)。当计算机需要发送信息的时候，也要通过网卡发送。一台计算机可以有不只一个网卡，比如笔记本就有一个以太网卡和一个WiFi网卡。计算机在接收或者发送信息的时候，要先决定想要通过哪个网卡。</p>
<p>路由器(router)实际上就是一台配备有多个网卡的专用电脑。它让网卡接入到不同的网络中。</p>
<h3 id="IP-包接力"><a href="#IP-包接力" class="headerlink" title="IP 包接力"></a>IP 包接力</h3><p>IP 包的传输要通过路由器的接力。每一个主机和路由中都存有一个路由表(routing table)。路由表根据目的地的 IP 地址，规定了等待发送的 IP 包所应该走的路线。</p>
<p>比如我们从主机 145.17 生成发送到 146.21 的IP包，注明目的地IP地址(199.165.146.21)和发出地IP地址(199.165.145.17)。主机 145.17 随后参照自己的 routing table，里面有三行记录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">145.17 routing table (Genmask为子网掩码,Iface用于说明使用哪个网卡接口)</div><div class="line">Destination        Gateway             Genmask             Iface</div><div class="line">199.165.145.0      0.0.0.0             255.255.255.0       eth0</div><div class="line">0.0.0.0            199.165.145.17      0.0.0.0             eth0</div></pre></td></tr></table></figure>
<p>这里有两行记录。</p>
<p>第一行表示，如果 IP 目的地是 199.165.145.0 这个网络的主机，那么只需要自己在 eth0 上的网卡直接传送，不需要前往 router(Gateway 0.0.0.0 = “本地”)。</p>
<p>第二行表示所有不符合第一行的 IP 目的地，都应该送往 Gateway 199.165.145.17，也就是中间 router 接入在 eth0 的网卡 IP 地址。</p>
<p>我们的 IP 包目的地为 199.165.146.21，不符合第一行，所以按照第二行，发送到中间的 router。主机 145.17 会将 IP 包放入帧的 payload，并在帧的头部写上 199.165.145.17 对应的 MAC 地址，这样，就可以在局域网中传送了。</p>
<p>中间的 router 在收到 IP 包之后(实际上是收到以太协议的帧，然后从帧中的 payload 读取 IP 包)，提取目的地IP地址，然后对照自己的routing table：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Destination        Gateway             Genmask             Iface</div><div class="line">199.165.145.0      0.0.0.0             255.255.255.0       eth0</div><div class="line">199.165.146.0      0.0.0.0             255.255.255.0       eth1</div><div class="line">0.0.0.0            199.165.146.8       0.0.0.0             eth1</div></pre></td></tr></table></figure>
<p>从前两行我们看到，由于 router 横跨 eth0 和 eth1 两个网络，它可以直接通过 eth0 和 eth1 上的网卡直接传送IP包。</p>
<p>第三行表示，如果是前面两行之外的 IP 地址，则需要通过 eth1，送往 199.165.146.8(右边的router)。</p>
<p>我们的目的地符合第二行，所以将IP放入一个新的帧中，</p>
<p>在帧的头部写上 199.165.146.21 的MAC地址，直接发往主机 146.21。</p>
<p>(在Linux下，可以使用 <code>$route -n</code> 来查看 routing table)</p>
<p>IP 包可以进一步接力，到达更远的主机。IP 包从主机出发，根据沿途路由器的 routing table 指导，在 router 间接力。IP 包最终到达某个 router，这个 router 与目标主机位于一个局域网中，可以直接建立连接层的通信。最后，IP 包被送到目标主机。这样一个过程叫做 routing(我们就叫 IP 包接力好了，路由这个词实在是混合了太多的意思)。</p>
<p>整个过程中，IP 包不断被主机和路由封装入帧并拆开，然后借助连接层，在局域网的各个 NIC 之间传送帧。整个过程中，我们的 IP 包的内容保持完整，没有发生变化。最终的效果是一个 IP 包从一个主机传送到另一个主机。利用 IP 包，我们不需要去操心底层(比如连接层)发生了什么。</p>
<h3 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h3><p>在上面的过程中，我们实际上假设了，每一台主机和路由都能了解局域网内的 IP 地址和 MAC 地址的对应关系，这是实现 IP 包封装(encapsulation)到帧的基本条件。IP 地址与 MAC 地址的对应是通过 ARP 协议传播到局域网的每个主机和路由。每一台主机或路由中都有一个 ARP cache，用以存储局域网内 IP 地址和 MAC 地址如何对应。</p>
<p>ARP 协议(ARP 介于连接层和网络层之间，ARP 包需要包裹在一个帧中)的工作方式如下：主机会发出一个 ARP 包，该 ARP 包中包含有自己的 IP 地址和 MAC 地址。通过 ARP 包，主机以广播的形式询问局域网上所有的主机和路由：我是 IP 地址 xxxx，我的 MAC 地址是 xxxx，有人知道 199.165.146.4 的MAC地址吗？拥有该 IP 地址的主机会回复发出请求的主机：哦，我知道，这个 IP 地址属于我的一个 NIC，它的 MAC 地址是 xxxxxx。由于发送 ARP 请求的主机采取的是广播形式，并附带有自己的 IP 地址和 MAC 地址，其他的主机和路由会同时检查自己的 ARP cache，如果不符合，则更新自己的 ARP cache。</p>
<p>这样，经过几次ARP请求之后，ARP cache会达到稳定。如果局域网上设备发生变动，ARP重复上面过程。</p>
<p>(在 Linux 下，可以使用 <code>$arp</code> 命令来查看 ARP 的过程。ARP 协议只用于 IPv4。IPv6 使用Neighbor Discovery Protocol 来替代 ARP 的功能。)</p>
<p><strong>Routing Table 的生成</strong></p>
<p>我们还有另一个假设，就是每个主机和路由上都已经有了合理的 routing table。这个 routing table描述了网络的拓扑(topology)结构。如果你了解自己的网络连接，可以手写自己主机的 routing table。但是，一个路由器可能有多个出口，所以 routing table 可能会很长。更重要的是，周围连接的其他路由器可能发生变动(比如新增路由器或者路由器坏掉)，我们就需要 routing table 能及时将交通导向其他的出口。我们需要一种更加智能的探测周围的网络拓扑结构，并自动生成 routing table。</p>
<p>一种用来生成 routing table 的协议是 RIP(Routing Information Protocol)。它通过距离来决定 routing table，所以属于 distance-vector protocol。对于RIP来说，所谓的距离是从出发地到目的地途径的路由器数目(hop number)。各个点不断重复RIP广播/计算距离/更新routing table的过程，最终所有的主机和路由器都能生成最合理的路径(merge)。</p>
<p>(RIP的基本逻辑是：如果A距离B为6，而我距离A为1，那么我途径A到B的距离为7)</p>
<p>RIP出于技术上的原因(looping hops)，认为距离超过15的IP不可到达。所以RIP更多用于互联网的一部分(比如整个中国电信的网络)。这样一个互联网的部分往往属于同一个 ISP 或者有同一个管理机构，所以叫做自治系统(AS,autonomous system)。自治系统内部的主机和路由根据通向外部的边界路由器来和其它的自治系统通信。各个边界路由器之间通过 BGP(Border Gateway Protocol)来生成自己前往其它 AS 的 routing table，而自治系统内部则参照边界路由器，使用 RIP 来决定 routing table。BGP 的基本工作过程与 RIP 类似，但在考虑距离的同时，也权衡比如政策、连接性能等其他因素，再决定交通的走向(routing table)。</p>
<h3 id="地址耗尽危机"><a href="#地址耗尽危机" class="headerlink" title="地址耗尽危机"></a>地址耗尽危机</h3><p>IP 地址是 IP 协议的重要组成部分，它可以识别接入互联网中的任意一台设备。在 IP 接力中，我们已经看到，IP 包的头部写有出发地和目的地的 IP 地址。IP 包上携带的 IP 地址和路由器相配合，最终允许 IP 包从互联网的一台电脑传送到另一台。</p>
<p>在 IP 接力中，我们是以 IPv4 为例说明 IP 包的格式的。IPv4 和 IPv6 是先后出现的两个 IP 协议版本。IPv4 的地址就是一个 32 位的 0/1 序列，比如 11000000 00000000 0000000 00000011。为了方便人类记录和阅读，我们通常将 32 位 0/1 分成 4 段 8 位序列，并用 10 进制来表示每一段(这样，一段的范围就是 0 到 255)，段与段之间以 <code>.</code> 分隔。比如上面的地址可以表示成为 192.0.0.3。IPv6 地址是 128 位 0/1 序列，它也按照 8 位分割，以 16 进制来记录每一段(使用 16 进制而不是 10 进制，这能让写出来的 IPv6 地址短一些)，段与段之间以 <code>:</code> 分隔。</p>
<p>IP地址的分配是一个政策性的问题。ICANN(the Internet Corporation for Assigned Names and Numbers) 是 Internet 的中心管理机构。ICANN 的 IANA(Internet Assigned Numbers Authourity)部门负责将 IP 地址分配给 5 个区域性的互联网注册机构(RIR，Reginal Internet Registry)，比如 APNIC，它负责亚太地区的 IP 分配。然后 RIR 将地址进一步分配给当地的ISP(Internet Service Provider)，比如中国电信和中国网通。ISP 再根据自己的情况，将 IP 地址分配给机构或者直接分配给用户，比如将 A 类地址分配给一个超大型机构，而将 C 类地址分配给一个网吧。机构可以进一步在局域网内部分配 IP 地址给各个主机。(A/B/C类地址请参阅IP接力)</p>
<p>并不是所有的地址都会被分配。一些地址被预留，用于广播、测试、私有网络使用等。这些地址被称为专用地址(special-use address)。你可以查询 RFC5735 来了解哪些地址是专用地址。</p>
<p>(RFC，Request For Comments。RFC是一系列的技术文档，用于记录Internet相关的技术和协议规定。每一个RFC文件都有一个固定的编号。它们是互联网的一个重要财产。你可以通过 <a href="http://www.rfc-editor.org/" target="_blank" rel="external">http://www.rfc-editor.org/</a> 来查找RFC文件)</p>
<p>由于IPv4协议的地址为32位，所以它可以提供 <code>2^32</code> , 也就是大约 40 亿个地址。如果地球人每人一个 IP 地址的话，IPv4 地址已经远远不够。更何况，人均持有的入网设备可能要远多于一个</p>
<p>尽管一些技术措施（比如NAT技术）减缓了情况的紧急程度，但 IPv4 地址耗尽的一天终究还是会很快到来。很明显，我们需要更多的 IP 地址，以满足爆炸式增长的互联网设备对 IP 地址的需求。</p>
<p>IPv6协议的地址最重要的改进就是：加长。IPv6的地址为128位。准确的说，IPv4有4,294,967,296个地址，而IPv6有</p>
<p>340,282,366,920,938,463,374,607,431,768,211,456</p>
<p>个地址。这是怎样一个概念呢？我们可以大概计算一下</p>
<p>地球表面积大约为 510,067,866,000,000 平方米。在一平方厘米(大约是指甲盖大小)的面积内，我们可以有 <code>6.67x10^16</code> 个 IP 地址！所以在短期的时间内，我们应该不会看到 IPv6 被用尽的尴尬。(不排除在未来计算机以分子尺寸出现，那么我们就会有IPv6耗尽危机了)</p>
<p>IPv4 地址正在耗尽，而 IPv6 通过更长的序列提供了更多的 IP 地址。IPv4 向 IPv6 的迁移正在发生。</p>
<p>阻碍迁移的过程的主要在于 IPv4 和 IPv6 格式的不兼容性。老的路由器支持 IPv4 格式的IP包，但它们无法理解 IPv6 格式的 IP 包。所以这一迁移过程必然要伴随者设备的更新。然而，我们的许多互联网资产都是建立在 IPv4 网络上的，不可能一夜之间停止 IPv4 网络的服务而整体迁移到 IPv6 网络中。这一迁移过程注定充满坎坷。</p>
<h3 id="IP-协议详解"><a href="#IP-协议详解" class="headerlink" title="IP 协议详解"></a>IP 协议详解</h3><p>在粗略了解了IP接力和IP地址后，我们再反过来，看一看IP协议的具体细节和设计哲学。</p>
<p>我们已经在IP接力中介绍过，一个IP包分为头部(header)和数据(payload/data)两部分。头部是为了实现IP通信必须的附加信息，数据是IP通信所要传送的信息。</p>
<p><img src="/images/14551393750144.jpg" alt=""></p>
<p><strong>黄色区域 (同名区域)</strong></p>
<p>我们看到，三个黄色区域跨越了 IPv4 和 IPv6。Version(4位)用来表明 IP 协议版本，是 IPv4 还是 IPv6(IPv4, Version=0100; IPv6, Version=0110)。Source Adrresss 和 Destination Address 分别为发出地和目的地的 IP 地址。</p>
<p><strong>蓝色区域 （名字发生变动的区域）</strong></p>
<p>Time to Live 存活时间(Hop Limit in IPv6)。Time to Live 最初是表示一个 IP 包的最大存活时间：如果 IP 包在传输过程中超过 Time to Live，那么 IP 包就作废。后来，IPv4 的这个区域记录一个整数(比如30)，表示在 IP 包接力过程中最多经过30个路由接力，如果超过30个路由接力，那么这个 IP 包就作废。IP 包每经过一个路由器，路由器就给 Time to Live 减一。当一个路由器发现 Time to Live 为0时，就不再发送该 IP 包。IPv6 中的 Hop Limit 区域记录的也是最大路由接力数，与 IPv4 的功能相同。Time to Live/Hop Limit 避免了 IP 包在互联网中无限接力。</p>
<p>Type of Service 服务类型(Traffic Class in IPv6)。Type of Service 最初是用来给 IP 包分优先级，比如语音通话需要实时性，所以它的 IP 包应该比 Web 服务的 IP 包有更高的优先级。然而，这个最初不错的想法没有被微软采纳。在Windows下生成的 IP 包都是相同的最高优先级，所以在当时造成 Linux 和 Windows 混合网络中，Linux 的 IP 传输会慢于 Windows (仅仅是因为Linux更加守规矩！)。后来，Type of Service 被实际分为两部分：Differentiated Service Field (DS, 前6位)和 Explicit Congestion Notification (ECN, 后2位)，前者依然用来区分服务类型，而后者用于表明 IP 包途径路由的交通状况。IPv6 的T raffic Class 也被如此分成两部分。通过IP包提供不同服务的想法，并针对服务进行不同的优化的想法已经产生很久了，但具体做法并没有形成公认的协议。比如 ECN 区域，它用来表示 IP 包经过路径的交通状况。如果接收者收到的 ECN 区域显示路径上的很拥挤，那么接收者应该作出调整。但在实际上，许多接收者都会忽视 ECN 所包含的信息。交通状况的控制往往由更高层的比如 TCP 协议实现。</p>
<p>Protocol 协议(Next Header in IPv6)。Protocol 用来说明 IP 包 Payload 部分所遵循的协议，也就是 IP 包之上的协议是什么。它说明了 IP 包封装的是一个怎样的高层协议包(TCP? UDP?)。</p>
<p>Total Length, 以及 IPv6 中 Payload Length 的讨论要和 IHL 区域放在一起，我们即将讨论。</p>
<p><strong>红色区域 (IPv6中删除的区域)</strong></p>
<p>我们看一下 IPv4 和 IPv6 的长度信息。IPv4 头部的长度。在头部的最后，是 options。每个 options 有32位，是选填性质的区域。一个 IPv4 头部可以完全没有 options 区域。不考虑 options 的话，整个 IPv4 头部有 20 bytes(上面每行为4 bytes)。但由于有 options 的存在，整个头部的总长度是变动的。我们用 IHL(Internet Header Length)来记录头部的总长度，用 Total Length 记录整个 IP 包的长度。IPv6 没有 options，它的头部是固定的长度 40 bytes，所以 IPv6 中并不需要 IHL 区域。Payload Length 用来表示 IPv6 的数据部分的长度。整个 IP 包为 40 bytes + Payload Length。</p>
<p>IPv4 中还有一个 Header Checksum 区域。这个 checksum 用于校验 IP 包的头部信息。Checksum 与之前的 CRC 算法并不相同。IPv6 则没有 checksum 区域。IPv6 包的校验依赖高层的协议来完成，这样的好处是免去了执行 checksum 校验所需要的时间，减小了网络延迟 (latency)。</p>
<p>Identification, flags 和 fragment offset，这三个包都是为碎片化(fragmentation)服务的。碎片化是指一个路由器将接收到的 IP 包分拆成多个 IP 包传送，而接收这些“碎片”的路由器或者主机需要将“碎片”重新组合(reassembly)成一个 IP 包。不同的局域网所支持的最大传输单元(MTU, Maximum Transportation Unit)不同。如果一个 IP 包的大小超过了局域网支持的MTU，就需要在进入该局域网时碎片化传输(就好像方面面面饼太大了，必须掰碎才能放进碗里)。碎片化会给路由器和网络带来很大的负担。最好在 IP 包发出之前探测整个路径上的最小 MTU，IP 包的大小不超过该最小MTU，就可以避免碎片化。IPv6 在设计上避免碎片化。每一个 IPv6 局域网的 MTU 都必须大于等于1280 bytes。IPv6 的默认发送 IP 包大小为 1280 bytes。</p>
<p><strong>绿色区域 (IPv6新增区域)</strong></p>
<p>Flow Label 是 IPv6 中新增的区域。它被用来提醒路由器来重复使用之前的接力路径。这样IP包可以自动保持出发时的顺序。这对于流媒体之类的应用有帮助。Flow label 的进一步使用还在开发中。</p>
<p><strong>我尽力</strong></p>
<p>IP 协议在产生时是一个松散的网络，这个网络由各个大学的局域网相互连接成的，由一群碰头垢面的 Geek 维护。所以，IP 协议认为自己所处的环境是不可靠(unreliable)的：诸如路由器坏掉、实验室失火、某个 PhD 踢掉电缆之类的事情随时会发生。</p>
<p>这样的凶险环境下，IP 协议提供的传送只能是“我尽力” (best effort)式的。所谓的“我尽力”，其潜台词是，如果事情出错不要怪我，我只是答应了尽力，可没保证什么。所以，如果 IP 包传输过程中出现错误(比如 checksum 对不上，比如交通太繁忙，比如超过 Time to Live)，根据 IP 协议，你的 IP 包会直接被丢掉。Game Over, 不会再有进一步的努力来修正错误。Best effort让IP协议保持很简单的形态。更多的质量控制交给高层协议处理，IP协议只负责有效率的传输。</p>
<p>“效率优先”也体现在IP包的顺序(order)上。即使出发地和目的地保持不变，IP 协议也不保证 IP 包到达的先后顺序。我们已经知道，IP 接力是根据 routing table 决定接力路线的。如果在连续的 IP 包发送过程中，routing table 更新(比如有一条新建的捷径出现)，那么后发出的 IP 包选择走不一样的接力路线。如果新的路径传输速度更快，那么后发出的 IP 包有可能先到。这就好像是多车道的公路上，每辆车都在不停变换车道，最终所有的车道都塞满汽车。这样可以让公路利用率达到最大。</p>
<p>IPv6 中的 Flow Label 可以建议路由器将一些 IP 包保持一样的接力路径。但这只是“建议”，路由器可能会忽略该建议。</p>
<h3 id="Header-Checksum算法"><a href="#Header-Checksum算法" class="headerlink" title="Header Checksum算法"></a>Header Checksum算法</h3><p>Header Checksum 区域有 16 位。它是这样获得的，从 header 取得除 checksum 之外的0/1序列，比如：</p>
<p>9194 8073 0000 4000 4011 C0A8 0001 C0A8 00C7 (十六进制 hex, 这是一个为演示运算过程而设计的header)</p>
<p>按照十六位(也就是 4 位 hex)分割整个序列。将分割后的各个 4 位 hex 累积相加。如果有超过 16 位的进位出现，则将进位加到后 16 位结果的最后一位：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">  Binary                Hex</div><div class="line">  1001000110010100      9194</div><div class="line">+ 1000000001110011      8073</div><div class="line">  ----------------</div><div class="line">1 0001001000000111     11207</div><div class="line">+                1</div><div class="line">  ----------------</div><div class="line">  0001001000001000      1208</div></pre></td></tr></table></figure>
<p>上面的计算叫做 one’s complement sum。求得所有十六位数的和，</p>
<p>one’s complement sum(4500, 0073, 0000, 4000, 4011, C0A8, 0001, C0A8, 00C7) = 1433</p>
<p>然后，将1433的每一位取反(0-&gt;1, 1-&gt;0)， 就得到checksum：EBCC</p>
<p>这样，我们的header就是:</p>
<p>9194 8073 0000 4000 4011 EBCC C0A8 0001 C0A8 00C7</p>
<p>IP 包的接收方在接收到 IP 包之后，可以求上面各个 16 位数的 one’s complement sum，应该得到 FFFF。如果不是 FFFF，那么 header 是不正确的，整个 IP 包会被丢弃。</p>
<p>(再次提醒，示例所用的 IP header 不是真实的 header，它只是起演示算法的作用)</p>
<p>每个网络协议的形成都有其历史原因。比如 IP 协议是为了将各个分散的实验室网络连接起来。由于当时的网络很小，所以 IPv4(IPv4产生与70年代)的地址总量为 40 亿。尽管当时被认为是很大的数字，但数字浪潮很快带来了地址耗尽危机。IPv6 的主要目的是增加 IPv4 的地址容量，但同时根据 IPv4 的经验和新时代的技术进步进行改进，比如避免碎片化，比如取消 checksum (由于高层协议 TCP 的广泛使用)。网络协议技术上并不复杂，更多的考量是政策性的。</p>
<p>IP协议是”Best Effort”式的，IP传输是不可靠的。但这样的设计成就了IP协议的效率。</p>
<h3 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h3><p>到现在为止，我们讲解了网络层中最重要的IP协议。IP协议的一个重要补充是是ICMP协议。</p>
<p>ICMP(Internet Control Message Protocol)是介于网络层和传输层的协议。它的主要功能是传输网络诊断信息。</p>
<p>ICMP传输的信息可以分为两类，一类是错误(error)信息，这一类信息可用来诊断网络故障。我们已经知道，IP协议的工作方式是“Best Effort”，如果IP包没有被传送到目的地，或者IP包发生错误，IP协议本身不会做进一步的努力。但上游发送 IP 包的主机和接力的路由器并不知道下游发生了错误和故障，它们可能继续发送 IP 包。通过 ICMP 包，下游的路由器和主机可以将错误信息汇报给上游，从而让上游的路由器和主机进行调整。需要注意的是，ICMP 只提供特定类型的错误汇报，它不能帮助 IP 协议成为“可靠”(reliable)的协议。另一类信息是咨询(Informational)性质的，比如某台计算机询问路径上的每个路由器都是谁，然后各个路由器同样用 ICMP 包回答。</p>
<p>(ICMP 基于 IP 协议。也就是说，一个 ICMP 包需要封装在 IP 包中，然后在互联网传送。ICMP 是 IP 套装的必须部分，也就是说，任何一个支持 IP 协议的计算机，都要同时实现 ICMP。)</p>
<p>ICMP包的结构：</p>
<p><img src="/images/14551393925085.jpg" alt=""></p>
<p>ICMP 包都会有 Type, Code 和 Checksum 三部分。Type 表示 ICMP 包的大的类型，而 Code 是一个 Type 之内细分的小类型。针对不同的错误信息或者咨询信息，会有不同的 Type 和 Code。从上面我们可以看到，ICMP 支持的类型非常多，就好像瑞士军刀一样，有各种各样的功能。Checksum 与 IP 协议的 header checksum 相类似，但与 IP 协议中 checksum 只校验头部不同，这里的 Checksum 所校验的是整个 ICMP 包(包括头部和数据)。</p>
<p>余下的 ICMP 包格式根据不同的类型不同。另一方面，ICMP 包通常是由某个 IP 包触发的。这个触发 IP 包的头部和一部份数据会被包含在 ICMP 包的数据部分。</p>
<p>ICMP 协议是实现 ping 命令和 traceroute 命令的基础。这两个工具常用于网络排错。</p>
<h3 id="常见的ICMP包类型"><a href="#常见的ICMP包类型" class="headerlink" title="常见的ICMP包类型"></a>常见的ICMP包类型</h3><p><strong>回音</strong></p>
<p>回音(Echo)属于咨询信息。ping 命令就是利用了该类型的 ICMP包。当使用 ping 命令的时候，将向目标主机发送Echo-询问类型的 ICMP 包，而目标主机在接收到该 ICMP 包之后，会回复Echo-回答类型的 ICMP 包，并将询问 ICMP 包包含在数据部分。ping 命令是我们进行网络排查的一个重要工具。如果一个 IP 地址可以通过 ping 命令收到回复，那么其他的网络协议通信方式也很有可能成功。</p>
<p><strong>源头冷却</strong></p>
<p>源头冷却(source quench)属于错误信息。如果某个主机快速的向目的地传送数据，而目的地主机没有匹配的处理能力，目的地主机可以向出发主机发出该类型的 ICMP 包，提醒出发主机放慢发送速度。</p>
<p><strong>目的地无法到达</strong></p>
<p>目的地无法到达(Destination Unreachable)属于错误信息。如果一个路由器接收到一个没办法进一步接力的 IP 包，它会向出发主机发送该类型的 ICMP 包。比如当 IP 包到达最后一个路由器，路由器发现目的地主机 down 机，就会向出发主机发送目的地无法到达(Destination Unreachable)类型的 ICMP 包。目的地无法到达还可能有其他的原因，比如不存在接力路径，比如不被接收的端口号等等。</p>
<p><strong>超时</strong></p>
<p>超时(Time Exceeded)属于错误信息。IPv4 中的 Time to Live(TTL)和 IPv6 中的 Hop Limit会随着经过的路由器而递减，当这个区域值减为 0 时，就认为该 IP 包超时(Time Exceeded)。Time Exceeded 就是 TTL 减为 0 时的路由器发给出发主机的 ICMP 包，通知它发生了超时错误。</p>
<p>traceroute 就利用了这种类型的ICMP包。traceroute 命令用来发现 IP 接力路径(route)上的各个路由器。它向目的地发送 IP 包，第一次的时候，将 TTL 设置为 1，引发第一个路由器的 Time Exceeded 错误。这样，第一个路由器回复 ICMP 包，从而让出发主机知道途径的第一个路由器的信息。随后 TTL 被设置为 2、3、4，…，直到到达目的主机。这样，沿途的每个路由器都会向出发主机发送 ICMP 包来汇报错误。traceroute 将 ICMP 包的信息打印在屏幕上，就是接力路径的信息了。</p>
<p><strong>重新定向</strong></p>
<p>重新定向(redirect)属于错误信息。当一个路由器收到一个 IP 包，对照其 routing table，发现自己不应该收到该 IP 包，它会向出发主机发送重新定向类型的 ICMP，提醒出发主机修改自己的routing table。比如下面的网络：</p>
<p><img src="/images/14551394092221.jpg" alt=""></p>
<p>假如 145.1 发送到 145.15 的 IP 包，结果被中间的路由器通过 145.17 的 NIC 收到。那么路由器会发现，根据自己的 routing table，这个 IP 包要原路返回。那么 router 就可以判断出 145.1 的 routing table 可能有问题。所以路由器会向 145.1 发送 redirect 类型的 ICMP 包。</p>
<p><strong>IPv6 的 Neighbor Discovery</strong></p>
<p>ARP 协议用于发现周边的 IP 地址和 MAC 地址的对应。然而，ARP 协议只用于 IPv4，IPv6 并不使用 ARP 协议。IPv6 包通过邻居探索(ND, Neighbor Discovery)来实现 ARP 的功能。ND 的工作方式与 ARP 类似，但它基于 ICMP 协议。ICMP 包有 Neighbor Solicitation 和 Neighbor Advertisement 类型。这两个类型分别对应ARP协议的询问和回复信息。</p>
<p>ICMP 协议是 IP 协议的排错帮手，它可以帮助人们及时发现 IP 通信中出现的故障。基于 ICMP 的 ping 和 traceroute 也构成了重要的网络诊断工具。然而，需要注意的是，尽管 ICMP 的设计是出于好的意图，但 ICMP 却经常被黑客借用进行网络攻击，比如利用伪造的 IP 包引发大量的 ICMP 回复，并将这些 ICMP 包导向受害主机，从而形成 DoS 攻击。而 redirect 类型的 ICMP 包可以引起某个主机更改自己的 routing table，所以也被用作攻击工具。许多站点选择忽视某些类型的 ICMP 包来提高自身的安全性。</p>
<h2 id="传输层协议"><a href="#传输层协议" class="headerlink" title="传输层协议"></a>传输层协议</h2><h3 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h3><p>我们已经讲解了物理层、连接层和网络层。最开始的连接层协议种类繁多(Ethernet、Wifi、ARP等等)。到了网络层，我们只剩下一个 IP 协议(IPv4和IPv6是替代关系)。进入到传输层(transport layer)，协议的种类又开始繁多起来(比如 TCP、UDP、SCTP 等)。这就好像下面的大树，根部(连接层)分叉很多，然后统一到一个树干(网络层)，到了树冠(传输层)部分又开始开始分叉，而每个树枝上长出更多的树叶(应用层)。我们在网络层已经看到，通过树干的统一，我们实现了一个覆盖全球的互联网络(Internet)。然而，我们可能出于不同的目的利用这张“网”，随之使用的方式也有所区分。不同的传输层协议(以及更多的应用层协议)正是我们使用“网”的不同方式的体现。</p>
<p>传输层最重要的协议为 TCP 协议和 UDP 协议。这两者使用“网”的方式走了两个极端。两个协议的对比非常有趣。TCP 协议复杂，但传输可靠。UDP 协议简单，但传输不可靠。其他的各个传输层协议在某种程度上都是这两个协议的折中。我们先来看传输层协议中比较简单的 UDP 协议。</p>
<p>UDP(User Datagram Protocol)传输与 IP 传输非常类似。你可以将 UDP 协议看作 IP 协议暴露在传输层的一个接口。UDP 协议同样以数据包(datagram)的方式传输，它的传输方式也是”Best Effort”的，所以 UDP 协议也是不可靠的(unreliable)。那么，我们为什么不直接使用 IP 协议而要额外增加一个 UDP 协议呢？一个重要的原因是 IP 协议中并没有端口(port)的概念。IP 协议进行的是 IP 地址到 IP 地址的传输，这意味者两台计算机之间的对话。但每台计算机中需要有多个通信通道，并将多个通信通道分配给不同的进程使用。一个端口就代表了这样的一个通信通道。正如我们在邮局和邮差中提到的收信人的概念一样。UDP 协议实现了端口，从而让数据包可以在送到 IP 地址的基础上，进一步可以送到某个端口。</p>
<p>尽管 UDP 协议非常简单，但它的产生晚于更加复杂的 TCP 协议。早期的网络开发者开发出 IP 协议和 TCP 协议分别位于网络层和传输层，所有的通信都要先经过 TCP 封装，再经过 IP 封装(应用层-&gt;TCP-&gt;IP)。开发者将 TCP/IP 视为相互合作的套装。但很快，网络开发者发现，IP 协议的功能和 TCP 协议的功能是相互独立的。对于一些简单的通信，我们只需要“Best Effort”式的 IP 传输就可以了，而不需要 TCP 协议复杂的建立连接的方式(特别是在早期网络环境中，如果过多的建立 TCP 连接，会造成很大的网络负担，而 UDP 协议可以相对快速的处理这些简单通信)。UDP 协议随之被开发出来，作为 IP 协议在传输层的”傀儡”。这样，网络通信可以通过应用层-&gt;UDP-&gt;IP 的封装方式，绕过 TCP 协议。由于 UDP 协议本身异常简单，实际上只为 IP 传输起到了桥梁的作用。我们将在 TCP 协议的讲解中看到更多 TCP 协议和 UDP 协议的对比。</p>
<p>UDP 的数据包同样分为头部(header)和数据(payload)两部分。UDP 是传输层(transport layer)协议，这意味着 UDP 的数据包需要经过 IP 协议的封装(encapsulation)，然后通过 IP 协议传输到目的电脑。随后 UDP 包在目的电脑拆封，并将信息送到相应端口的缓存中。</p>
<p><strong>UDP协议的头部</strong></p>
<p><img src="/images/14551394375473.jpg" alt=""></p>
<p>上面的 source port 和 destination port 分别为 UDP 包的出发端口和目的地端口。Length 为整个 UDP 包的长度。</p>
<p>checksum 的算法与 IP 协议的 header checksum 算法相类似。然而，UDP 的 checksum 所校验的序列包括了整个 UDP 数据包，以及封装的 IP 头部的一些信息(主要为出发地 IP 和目的地 IP)。这样，checksum 就可以校验 IP：端口的正确性了。在 IPv4 中，checksum 可以为 0，意味着不使用 checksum。IPv6 要求必须进行 checksum 校验。</p>
<p><strong>端口与 socket</strong></p>
<p>端口(port)是伴随着传输层诞生的概念。它可以将网络层的 IP 通信分送到各个通信通道。UDP 协议和 TCP 协议尽管在工作方式上有很大的不同，但它们都建立了从一个端口到另一个端口的通信。</p>
<p>随着我们进入传输层，我们也可以调用操作系统中的 API，来构建 socket。Socket 是操作系统提供的一个编程接口，它用来代表某个网络通信。应用程序通过 socket 来调用系统内核中处理网络协议的模块，而这些内核模块会负责具体的网络协议的实施。这样，我们可以让内核来接收网络协议的细节，而我们只需要提供所要传输的内容就可以了，内核会帮我们控制格式，并进一步向底层封装。因此，在实际应用中，我们并不需要知道具体怎么构成一个 UDP 包，而只需要提供相关信息(比如 IP 地址，比如端口号，比如所要传输的信息)，操作系统内核会在传输之前会根据我们提供的相关信息构成一个合格的 UDP 包(以及下层的包和帧)。socket 是一个比较大的课题，在这里不会过多深入。</p>
<p>端口是传输层带来的最重要的概念。我们进一步了解了 UDP 协议。如果已经掌握了 IP 协议，那么 UD P协议就没有任何困难可言，它只是 IP 协议暴露在传输层上的接口。</p>
<h3 id="TCP协议与流通信"><a href="#TCP协议与流通信" class="headerlink" title="TCP协议与流通信"></a>TCP协议与流通信</h3><p>TCP(Transportation Control Protocol)协议与 IP 协议是一同产生的。事实上，两者最初是一个协议，后来才被分拆成网络层的 IP 和传输层的 TCP。我们已经在 UDP 协议中介绍过，UDP 协议是 IP 协议在传输层的“傀儡”，用来实现数据包形式的通信。而 TCP 协议则实现了“流”形式的通信。</p>
<p>TCP的内容非常丰富。我不能在一篇文章中将TCP讲完。这一篇主要介绍TCP协议的下面几个方面：</p>
<ol>
<li>“流”通信的意义与实现方式</li>
<li>如何实现可靠传输</li>
<li>使用滑窗提高效率</li>
</ol>
<p>TCP 协议是传输层协议，实现的是端口到端口(port)的通信。更进一步，TCP 协议虚拟了文本流(byte stream)的通信。在 Linux 文本流中我们谈到，计算机数据的本质是有序的 0/1 序列 (如果以 byte为单位，就叫做文本流)。计算机的功能就是储存和处理文本流。CPU + memory + 存储设备实现了文本流在同一台计算机内部的加工处理。通过一些 IO，比如屏幕和键盘，文本流实现了人机交互。而进一步，如果网络通信可在不同计算机之间进行文本流的交互，那么我们就和整个计算机系统的数据处理方式实现了对接。</p>
<p>IP 协议和 UDP 协议采用的是数据包的方式传送，后发出的数据包可能早到，我们并不能保证数据到达的次序。TCP 协议确保了数据到达的顺序与文本流顺序相符。当计算机从 TCP 协议的接口读取数据时，这些数据已经是排列好顺序的“流”了。比如我们有一个大文件要从本地主机发送到远程主机，如果是按照“流”接收到的话，我们可以一边接收，一边将文本流存入文件系统。这样，等到“流”接收完了，硬盘写入操作也已经完成。如果采取 UDP 的传输方式，我们需要等到所有的数据到达后，进行排序，才能组装成大的文件。这种情况下，我们不得不使用大量的计算机资源来存储已经到达的数据，直到所有数据都达到了，才能开始处理。</p>
<p>“流”的要点是次序(order)，然而实现这一点并不简单。TCP 协议是基于 IP 协议的，所以最终数据传送还是以 IP 数据包为单位进行的。如果一个文本流很长的话，我们不可能将整个文本流放入到一个 IP 数据包中，那样有可能会超过 MTU。所以，TCP 协议封装到 IP 包的不是整个文本流，而是 TCP 协议所规定的片段(segment)。与之前的一个 IP 或者 UDP 数据包类似，一个 TCP 片段同样分为头部(header)和数据(payload)两部分 (“片段”这个名字更多是起提醒作用：嘿，这里并不是完整的文本流)。整个文本流按照次序被分成小段，而每一段被放入 TCP 片段的数据部分。一个 TCP 片段封装成的 IP 包不超过整个 IP 接力路径上的最小 MTU，从而避免令人痛苦的碎片化(fragmentation)。</p>
<p>(给文本流分段是在发送主机完成的，而碎片化是在网络中的路由器完成的。路由器要处理许多路的通信，所以相当繁忙。文本流提前在发送主机分好段，可以避免在路由器上执行碎片化，可大大减小网络负担)</p>
<p>TCP 片段的头部(header)会存有该片段的序号(sequence number)。这样，接收的计算机就可以知道接收到的片段在原文本流中的顺序了，也可以知道自己下一步需要接收哪个片段以形成流。比如已经接收到了片段1，片段2，片段3，那么接收主机就开始期待片段4。如果接收到不符合顺序的数据包(比如片段8)，接收方的TCP模块可以拒绝接收，从而保证呈现给接收主机的信息是符合次序的“流”。</p>
<p><strong>可靠性</strong></p>
<p>片段编号这个初步的想法并不能解决我们所有的问题。IP 协议是不可靠的，所以 IP 数据包可能在传输过程中发生错误或者丢失。而IP传输是”Best Effort” 式的，如果发生异常情况，我们的IP数据包就会被轻易的丢弃掉。另一方面，如果乱序(out-of-order)片段到达，根据我们上面说的，接收主机不会接收。这样，错误片段、丢失片段和被拒片段的联手破坏之下，接收主机只可能收到一个充满“漏洞”的文本流。</p>
<p>TCP 的补救方法是，在每收到一个正确的、符合次序的片段之后，就向发送方(也就是连接的另一段)发送一个特殊的 TCP 片段，用来知会(ACK，acknowledge)发送方：我已经收到那个片段了。这个特殊的 TCP 片段叫做 ACK 回复。如果一个片段序号为 L，对应 ACK 回复有回复号 L+1，也就是接收方期待接收的下一个发送片段的序号。如果发送方在一定时间等待之后，还是没有收到 ACK 回复，那么它推断之前发送的片段一定发生了异常。发送方会重复发送(retransmit)那个出现异常的片段，等待 ACK 回复，如果还没有收到，那么再重复发送原片段… 直到收到该片段对应的 ACK 回复(回复号为L+1的ACK)。</p>
<p>当发送方收到 ACK 回复时，它看到里面的回复号为 L+1，也就是发送方下一个应该发送的 TCP 片段序号。发送方推断出之前的片段已经被正确的接收，随后发出 L+1 号片段。ACK 回复也有可能丢失。对于发送方来说，这和接收方拒绝发送 ACK 回复是一样的。发送方会重复发送，而接收方接收到已知会过的片段，推断出 ACK 回复丢失，会重新发送 ACK 回复。</p>
<p>通过ACK回复和重新发送机制，TCP 协议将片段传输变得可靠。尽管底盘是不可靠的 IP 协议，但 TCP 协议以一种“不放弃的精神”，不断尝试，最终成功。(技术也可以很励志)</p>
<p>TCP 协议和 UDP 协议走了两个极端。TCP 协议复杂但可靠，UDP 协议轻便但不可靠。在处理异常的时候，TCP 极端负责，而 UDP 一副无所谓的样子。</p>
<h3 id="滑窗"><a href="#滑窗" class="headerlink" title="滑窗"></a>滑窗</h3><p>上面的工作方式中，发送方保持发送-&gt;等待ACK-&gt;发送-&gt;等待ACK…的单线工作方式，这样的工作方式叫做 stop-and-wait。stop-and-wait 虽然实现了 TCP 通信的可靠性，但同时牺牲了网络通信的效率。在等待 ACK 的时间段内，我们的网络都处于闲置(idle)状态。我们希望有一种方式，可以同时发送出多个片段。然而如果同时发出多个片段，那么由于 IP 包传送是无次序的，有可能会生成乱序片段(out-of-order)，也就是后发出的片段先到达。在 stop-and-wait 的工作方式下，乱序片段完全被拒绝，这也很不效率。毕竟，乱序片段只是提前到达的片段。我们可以在缓存中先存放它，等到它之前的片段补充完毕，再将它缀在后面。然而，如果一个乱序片段实在是太过提前(太“乱”了)，该片段将长时间占用缓存。我们需要一种折中的方法来解决该问题：利用缓存保留一些“不那么乱”的片段，期望能在段时间内补充上之前的片段(暂不处理，但发送相应的 ACK)；对于“乱”的比较厉害的片段，则将它们拒绝(不处理，也不发送对应的 ACK)。</p>
<p>滑窗(sliding window)被同时应用于接收方和发送方，以解决以上问题。发送方和接收方各有一个滑窗。当片段位于滑窗中时，表示TCP正在处理该片段。滑窗中可以有多个片段，也就是可以同时处理多个片段。滑窗越大，越大的滑窗同时处理的片段数目越多(当然，计算机也必须分配出更多的缓存供滑窗使用)。TCP协议有实时调整滑窗大小的算法，以实现最优效率。</p>
<p>TCP协议和UDP协议走了两个极端。TCP协议复杂但可靠，UDP协议轻便但不可靠。在处理异常的时候，TCP极端负责，而UDP一副无所谓的样子。在TCP中，分段和编号实现了次序；ACK和重新发送实现了可靠性；sliding window则让上面的机制更加有效率的运行。Never give up，这就是TCP协议的态度。</p>
<h3 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h3><p>在 TCP 协议与”流”通信中，我们概念性的讲解了 TCP 通信的方式。可以看到，TCP 通信最重要的特征是：有序(ordering)和可靠(reliable)。有序是通过将文本流分段并编号实现的。可靠是通过 ACK 回复和重复发送(retransmission)实现的。这一篇文章将引入 TCP 连接(connection)的概念。</p>
<p>网络层在逻辑上提供了端口的概念。一个 I P地址可以有多个端口。一个具体的端口需要 IP 地址和端口号共同确定(我们记为 IP:port 的形式)。一个连接为两个 IP:port 之间建立 TCP 通信。</p>
<p>参与连接的如果是两台电脑，那么两台电脑操作系统的 TCP 模块负责建立连接。每个连接有四个参数(两个 IP，两个端口)，来表明“谁在和谁通话”。每台电脑都会记录有这四个参数，以确定是哪一个连接。如果这四个参数完全相同，则为同一连接；如果这四个参数有一个不同，即为不同的连接。这意味着，同一个端口上可以有多个连接。内核中的TCP模块生成连接之后，将连接分配给进程使用。</p>
<p>TCP 连接是双向(duplex)的。在 TCP 协议与”流”通信中，我们所展示的 TCP 传输是单向的。双向连接实际上就是建立两个方向的 TCP 传输，所以概念上并不复杂。这时，连接的每一方都需要两个滑窗，以分别处理发送的文本流和接收的文本流。由于连接的双向性，我们也要为两个方向的文本流编号。这两个文本流的编号相互独立。为文本流分段和编号由发送方来处理，回复 ACK 则由接收的一方进行。</p>
<p><strong>TCP片段的头部格式</strong></p>
<p>在深入 TCP 连接之前，我们需要对 TCP 片段的头部格式有一些了解。我们知道，TCP 片段分为头部和数据。数据部分为 TCP 真正传输的文本流数据。下面为 TCP 片段的头部格式：</p>
<p><img src="/images/14551394884094.jpg" alt=""></p>
<p>先关注下面几点：</p>
<ol>
<li>一个 TCP 头部需要包含出发端口(source port)和目的地端口(destination port)。这些与 IP 头中的两个 IP 地址共同确定了连接。</li>
<li>每个 TCP 片段都有序号(sequence number)。这些序号最终将数据部分的文本片段整理成为文本流。</li>
<li>ACK 是一位(bit)。只有 ACK 位设定的时候，回复号(Acknowledgement number)才有效。ACK 回复号说明了接收方期待接收的下一个片段，所以 ACK 回复号为最后接收到的片段序号加 1。<ul>
<li>很多时候，ACK 回复“附着”在发送的数据片段中。TCP 协议是双向的。比如 A 和 B 两个电脑。 ACK 回复是接收方回复给发送方 (比如 A 发送给 B， B 回复 A)。但同时，B 也可以是发送方，B 有可能有数据发送给 A，所以 B 就把 ACK 回复附着在它要发送给 A 的数据片段的头部。这样可以减少 ACK 所占用的交通流量。一个片段可以只包含 ACK 回复。一个纯粹的 ACK 回复片段不传送文本流，所以不消耗序列号。如果有下一个正常的数据片段，它的序号将与纯粹 ACK 回复片段的序号相同。</li>
<li>(ACK 回复还可以“附着”在 SYN 片段和 FIN 片段)</li>
</ul>
</li>
<li>ACK 后面还有 SYN 和 FIN，它们也各占据一位(bit)。我将在后面说明这两位。</li>
</ol>
<p><strong>连接的建立</strong></p>
<p>在 TCP 协议与”流”通信中讨论的 TCP 传输需要一个前提：TCP 连接已经建立。然而，TCP 连接从无到有需要一个建立连接的过程。建立连接的最重要目是让连接的双方交换初始序号(ISN, Initial Sequence Number)。根据 TCP 协议的规定，文本流的第一个片段的序号不能是确定的数字(比如说1)。连接的双方各自随机生成自己的 ISN，然后再利用的一定方式让对方了解。这样的规定是出于 TCP 连接安全考虑：如果以一个确定的数字作为初始的 TCP 序号，那么其他人很容易猜出接下来的序列号，并按照正确的序号发送“伪装”的 TCP 片段，以插入到文本流中。</p>
<p>ISN 交换是通过 SYN 片段实现的。SYN 片段由头部的 SYN 位表明，它的序号为发送方的 ISN。该片段由连接的一方首先发给给另一方，我们将发送 SYN 的一方称为客户(client)，而接收 SYN 的一方称为服务器(server)。我们使用 ISN(c) 表示 client 一方的 ISN，使用 ISN(s) 表示 server 一方的 ISN。随后，接收到 SYN 的 server 需要回复 ACK，并发送出包含有 server 的 ISN 的 SYN 片段。下图为建立连接的过程，也就是经典的 TCP 三次握手(three-way handshaking)。两条竖直线分别为 client 和 server 的时间轴。每个箭头代表了一次 TCP 片段的单向传输。</p>
<p><img src="/images/14551395013280.jpg" alt=""></p>
<p><strong>连接的正常终结</strong></p>
<p>一个连接建立之后，连接两端的进程可以利用该连接进行通信。当连接的一方觉得“我讲完了”，它可以终结连接中发送到对方方向的通信。连接最终通过四次握手(four-way handshaking)的方式终结，连接终结使用的是特殊片段 FIN(FIN位为1的片段)。</p>
<p><img src="/images/14551395178688.jpg" alt=""></p>
<p>我们可以看到，连接终结的过程中，连接双方也交换了四片信息(两个 FIN 和两个 ACK)。在终结连接的过程中，TCP 并没有合并 FIN 与 ACK 片段。原因是 TCP 连接允许单向关闭(half-close)。也就是说，TCP 连接关闭了一个方向的传输，成为一个单向连接(half-duplex)。第二个箭头和第三个箭头传递必须分开，才能有空隙在开放的方向上继续传输。如果第二个箭头和第三个箭头合并在一起，那么，随着一方关闭，另一方也要被迫关闭。</p>
<p>第二和第三次握手之间，server 可以继续单向的发送片段给 client，但 client 不能发送数据片段给 server。</p>
<p>(上面的终结从 client 先发起，TCP 连接终结也可以从 server 先发起。)</p>
<p>在 Client 发送出最后的 ACK 回复，但该 ACK 可能丢失。Server 如果没有收到 ACK，将不断重复发送 FIN 片段。所以 Client 不能立即关闭，它必须确认 Server 接收到了该 ACK。Client 会在发送出 ACK 之后进入到 <code>TIME_WAIT</code> 状态。Client 会设置一个计时器，等待 2MSL 的时间。如果在该时间内再次收到 FIN，那么 Client 会重发 ACK 并再次等待 2MSL。所谓的 2MSL 是两倍的 MSL(Maximum Segment Lifetime)。MSL 指一个片段在网络中最大的存活时间，2MSL 就是一个发送和一个回复所需的最大时间。如果直到 2MSL，Client 都没有再次收到 FIN，那么 Client 推断 ACK 已经被成功接收，则结束 TCP 连接。</p>
<p>TCP 是连接导向的协议，与之对应的是像 UDP 这样的非连接导向的协议。连接能带来更好的传输控制，但也需要更多额外的工作，比如连接的建立和终结。</p>
<p>我们还初步了解了 TCP 的头部格式。应该注意到，许多时候我们将 ACK 片段“附着”在其他片段上。相对于纯粹的 ACK 片段，我们这样做节约了 ACK 所需的流量。事实上，由于 ACK 片段所需的 ACK 位和 acknowledge number 区域总是存在于 TCP 的头部，所以附着 ACK 片段的成本基本上等于 0。</p>
<h3 id="TCP滑窗管理"><a href="#TCP滑窗管理" class="headerlink" title="TCP滑窗管理"></a>TCP滑窗管理</h3><p>在 TCP 协议与”流”通信中，我们建立了滑窗(sliding window)的基本概念。通过滑窗与 ACK 的配合，我们一方面实现了 TCP 传输的可靠性，另一方面也一定程度上提高了效率。</p>
<p>然而，之前的解释只是概念性的。TCP 为了达到更好的传输效率，对上面的工作方式进行了许多改进。The devil is in the details. 我们需要深入到细节，才能看清楚TCP协议的智慧所在。</p>
<p><strong>累计ACK</strong></p>
<p>在 TCP 连接中，我们通过将 ACK 回复“附着”在其他数据片段的方式，减少了 ACK 回复所消耗的流量。但这并不是全部的故事。TCP 协议并不是对每个片段都发送 ACK 回复。TCP 协议实际采用的是累计 ACK 回复(accumulative acknowledgement)。接收方往往利用一个 ACK 回复来知会连续多个片段的成功接收。通过累计 ACK，所需要的 ACK 回复通常可以降到 50%。</p>
<p>如下图所示，橙色为已经接收的片段。方框为滑窗，滑窗可容纳 3 个片段。</p>
<p><img src="/images/14551395342559.jpg" alt=""></p>
<p>滑窗还没接收到片段7时，已接收到片段8，9。这样就在滑窗中制造了一个“空穴”(hole)。当滑窗最终接收到片段7时，滑窗送出一个回复号为10的ACK回复。发送方收到该回复，会意识到，片段10之前的片段已经按照次序被成功接收。整个过程中节约了片段7和片段8所需的两个ACK回复。</p>
<p>此外，接收方在接收到片断，并应该回复ACK的时候，会故意延迟一些时间。如果在延迟的时间里，有后续的片段到达，就可以利用累计ACK来一起回复了。</p>
<p><strong>滑窗结构</strong></p>
<p>在之前的讨论中，我们以片段为单位，来衡量滑窗的大小的。真实的滑窗是以 byte 为单位表示大小，但这并不会对我们之前的讨论造成太大的影响。</p>
<p><img src="/images/14551395682155.jpg" alt=""></p>
<p>发送方滑窗可以分为下面两个部分。offered window 为整个滑窗的大小。</p>
<p><img src="/images/14551395777596.jpg" alt=""></p>
<p>可以看到，接收方的滑窗相对于发送方的滑窗多了一个”Received; ACKed; Not Sent to Proc”的部分。接收方接收到的文本流必须等待进程来读取。如果进程正忙于做别的事情，那么这些文本流即使已经正确接收，还是需要暂时占用接收缓存。当出现上述占用时，滑窗的可用部分(也就是图中advertised window)就会缩水。这意味着接收方的处理能力下降。如果这个时候发送方依然按照之前的速率发送数据给接收方，接收方将无力接收这些数据。</p>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>TCP协议会根据情况自动改变滑窗大小，以实现流量控制。流量控制(flow control)是指接收方将advertised window的大小通知给发送方，从而指导发送方修改 offered window 的大小。接收方将该信息放在 TCP 头部的 window size 区域：</p>
<p><img src="/images/14551395892901.jpg" alt=""></p>
<p>发送方在收到 window size 的通知时，会调整自己滑窗的大小，让 offered window 和advertised window 相符。这样，发送窗口变小，文本流发送速率降低，从而减少了接收方的负担。</p>
<p><strong>零窗口</strong></p>
<p>advertised window 大小有可能变为0，这意味着接收方的接收能力降为0。发送方收到大小为0的advertised window 通知时，停止发送。</p>
<p>当接收方经过处理，再次产生可用的 advertised window 时，接收方会通过纯粹的 ACK 回复来通知发送方，让发送方恢复发送。然而，ACK 回复的传送并不是可靠的。如果该 ACK 回复丢失，那么 TCP 传输将陷入死锁(deadlock)状态。</p>
<p>为此，发送方会在零窗口后，不断探测接收方的窗口。窗口探测(window probe)时，发送方会向接收方发送包含 1 byte 文本流的 TCP 片段，并等待 ACK 回复(该 ACK 回复包含有 window size)。由于有 1 byte 的数据存在，所以该传输是可靠的，而不用担心 ACK 回复丢失的问题。如果探测结果显示窗口依然为 0，发送方会等待更长的时间，然后再次进行窗口探测，直到 TCP 传输恢复。</p>
<p><strong>白痴窗口综合症</strong></p>
<p>滑窗机制有可能犯病，比如白痴窗口综合症 (Silly Window Syndrome)。假设这样一种情形：接收方宣布(advertise)一个小的窗口，发送方根据advertised window，发送一个小的片段。接收方的小窗口被填满，经过处理，接收方再宣布一个小的窗口…… 这就是“白痴窗口综合症”：TCP通信的片段中包含的数据量很小。在这样的情况下，TCP 通信的片段所含的信息都很小，网络流量主要是 TCP 片段的头部，从而造成流量的浪费 (由于 TCP 头部很大，我们希望每个 TCP 片段中含有比较多的数据)。</p>
<p>如果发送方不断发送小的片段，也会造成“白痴窗口”。为了解决这个问题，需要从两方面入手。TCP中有相关的规定，要求：</p>
<ol>
<li>接收方宣告的窗口必须达到一定的尺寸，否则等待。</li>
<li>除了一些特殊情况，发送方发送的片段必须达到一定的尺寸，否则等待。特殊情况主要是指需要最小化延迟的 TCP 应用(比如命令行互动)。</li>
</ol>
<p>累计 ACK 减少了 TCP 传输过程中所需的 ACK 流量。通过流量管理，TCP 连接两端的工作能力可以匹配，从而减少不不要的传输浪费。累计 ACK 和流量控制都是 TCP 协议的重要特征。</p>
<p>TCP 协议相当复杂，并充斥着各种细节。然而 TCP 协议又是如此重要的一个协议，引领风骚三十年，可以说是互联网的奇迹。这些细节正是 TCP 协议成功的原因，并值得我们深入了解。</p>
<h3 id="TCP重新发送"><a href="#TCP重新发送" class="headerlink" title="TCP重新发送"></a>TCP重新发送</h3><p>TCP 协议是一个可靠的协议。它通过重新发送(retransmission)来实现 TCP 片段传输的可靠性。简单的说，TCP 会不断重复发送 TCP 片段，直到片段被正确接收。</p>
<p><strong>TCP片段丢失</strong></p>
<p><img src="/images/14551396019064.jpg" alt=""></p>
<p>接收方(receiver)可以通过校验 TCP 片段头部中 checksum 区域来检验 TCP 片段是否出错。我们已经接触过了 IP 协议详解的 checksum 算法。TCP 片段的 checksum 算法与之类似。IP 协议的 checksum 只校验头部，TCP 片段头部的 checksum 会校验包括 IP 头部、TCP 头部和 TCP 数据在内的整个序列，确保 IP 地址、端口号和其他相关信息正确。如果 TCP 片段出错，接收方可以简单的丢弃改 TCP 片段，也就相当于 TCP 片段丢失。</p>
<p>TCP 片段包裹在一个 IP 包中传输。IP 包可能在网络中丢失。导致 IP 包丢失的原因可能有很多，比如 IP 包经过太多的路由器接力，达到 hop limit；比如路由器太过拥挤，导致一些 IP 包被丢弃；再比如路由表(routing table)没有及时更新，导致 IP 包无法送达目的地。</p>
<p>下面我们要介绍两种重新发送 TCP 片段的机制：超时重新发送和快速重新发送。 </p>
<p><strong>超时重新发送</strong></p>
<p>我们之前已经简单介绍过重新发送的机制：当发送方送出一个 TCP 片段后，将开始计时，等待该 TCP 片段的 ACK 回复。如果接收方正确接收到符合次序的片段，接收方会利用 ACK 片段回复发送方。发送方得到 ACK 回复后，继续移动窗口，发送接下来的 TCP 片段。如果直到计时完成，发送方还是没有收到 ACK 回复，那么发送方推断之前发送的 TCP 片段丢失，因此重新发送之前的 TCP 片段。这个计时等待的时间叫做重新发送超时时间(RTO, retransmission timeout)。</p>
<p>发送方应该在等待多长时间之后重新发送呢？这是重新发送的核心问题。上述过程实际上有往返两个方向：</p>
<ol>
<li>发送片段从发送方到接收方的传输，</li>
<li>ACK 片段从接收方到发送方的传输</li>
</ol>
<p>整个过程实际耗费的时间称做往返时间(RTT, round trip time)。如果 RTT 是固定的，比如1秒，那么我们可以让 RTO 等于 RTT。但实际上，RTT 的上下浮动很大。比如某个时刻，网络中有许多交通，那么 RTT 就增加。在 RTT 浮动的情况下，如果我们设置了过小的 RTO，那么 TCP 会等待很短的时间之后重新发送，而实际上之前发送的片段并没有丢失，只是传输速度比较慢而已，这样，网络中就被重复注入 TCP 片段，从而浪费网络传输资源。另一方面，如果 RTO 时间过长，那么当 TCP 片段已经实际丢失的情况下，发送方不能及时重新发送，会造成网络资源的闲置。所以，RTO 必须符合当前网络的使用状况。网络状况越好，RTO 应该越短；网络状况越差，RTO 应该越长。</p>
<p>TCP 协议通过统计 RTT，来决定合理的 RTO。发送方可以测量每一次 TCP 传输的 RTT (从发送出数据片段开始，到接收到 ACK 片段为止)，这样的每次测量得到的往返时间，叫做采样 RTT(srtt, sampling round trip time)。建立连接之后，每次的 srtt 作为采样样本，计算平均值(mean)和标准差(standard deviation)，并让 RTO 等于 srtt 平均值加上四倍的 srtt 标准差。</p>
<p>RTO = mean + 4 std</p>
<p>(上述算法有多个变种，根据平台不同有所变化)</p>
<p>平均值反映了平均意义上的 RTT，平均往返时间越大，RTO 越大。另一方面，标准差越大也会影响 RTO。标准差代表了 RTT 样本的离散程度。如果 RTT 上下剧烈浮动，标准差比较大。RTT 浮动大，说明当前网络状况相对不稳定。因此要设置更长的 RTO，以应对不稳定的网络状况。</p>
<p><strong>快速重新发送</strong></p>
<p>我们刚才介绍了超时重新发送的机制：发送方送出一个 TCP 片段，然后开始等待并计时，如果 RTO 时间之后还没有收到 AC K回复，发送方则重新发送。TCP 协议有可能在计时完成之前启动重新发送，也就是利用快速重新发送(fast-retransmission)。快速发送机制如果被启动，将打断计时器的等待，直接重新发送 TCP 片段。</p>
<p>由于IP包的传输是无序的，所以接收方有可能先收到后发出的片段，也就是乱序(out-of-order)片段。乱序片段的序号并不等于最近发出的ACK回复号。已接收的文本流和乱序片段之间将出现空洞(hole)，也就是等待接收的空位。比如已经接收了正常片段5,6,7，此时又接收乱序片段9。这时片段8依然空缺，片段8的位置就是一个空洞。</p>
<p>TCP 协议规定，当接收方收到乱序片段的时候，需要重复发送 ACK。比如接收到乱序片段 9 的时候，接收方需要回复 ACK。回复号为 8 (7+1)。此后接收方如果继续收到乱序片段(序号不是8的片段)，将再次重复发送 ACK=8。当发送方收到 3 个 ACK=8 的回复时，发送方推断片段 8 丢失。即使此时片段 8 的计时器还没有超时，发送方会打断计时，直接重新发送片段 8，这就是快速重新发送机制(fast-retransmission)。</p>
<p>快速重新发送机制利用重复的 ACK 来提示空洞的存在。当重复次数达到阈值时，认为空洞对应的片段在网络中丢失。快速重新发送机制提高了检测丢失片段的效率，往往可以在超时之前探测到丢失片段，并重复发送丢失的片段。</p>
<h3 id="TCP堵塞控制"><a href="#TCP堵塞控制" class="headerlink" title="TCP堵塞控制"></a>TCP堵塞控制</h3><p>在 TCP 协议中，我们使用连接记录 TCP 两端的状态，使用编号和分段实现了 TCP 传输的有序，使用 advertised window 来实现了发送方和接收方处理能力的匹配，并使用重复发送来实现 TCP 传输的可靠性。我们只需要将 TCP 片段包装成 IP 包，扔到网络中就可以了。TCP 协议的相关模块会帮我们处理各种可能出现的问题(比如排序，比如TCP片段丢失等等)。最初的 TCP 协议就是由上述的几大块构成的。</p>
<p>然而进入上世纪八十年代，网络开始变的繁忙。许多网络中出现了大量的堵塞(congestion)。堵塞类似于现实中的堵车。网络被称为“信息高速公路”。许多汽车(IP包)在网络中行驶，并经过一个一个路口 (路由器)，直到到达目的地。一个路由器如果过度繁忙，会丢弃一些 IP 包。UDP 协议不保证传输的可靠性，所以丢失就丢失了。而 TCP 协议需要保证传输的可靠性，当包含有 TCP 片段的 IP 包丢失时，TCP 协议会重复发送 TCP 片段。于是，更多的“汽车”进入到公路中，原本繁忙的路由器变得更加繁忙，更多的IP包丢失。这样就构成了一个恶性循环。这样的情况被称为堵塞崩溃(congestion collapse)。每个发送方为了保证自己的发送质量，而不顾及公共领域现状，是造成堵塞崩溃的主要原因。当时的网络中高达90%的传输资源可能被堵塞崩溃所浪费。</p>
<p>为了解决这一缺陷，从八十年代开始，TCP 协议中开始加入堵塞控制(congestion control)的功能，以避免堵塞崩溃的出现。多个算法被提出并实施，大大改善了网络的交通状况。直到今天，堵塞控制依然是互联网研究的一个活跃领域。</p>
<p>现实中，当我们遇到堵车，可能就会希望兴建立交桥和高架，或者希望有一位交警来疏导交通。而 TCP 协议的堵塞控制是通过约束自己实现的。当 TCP 的发送方探测到网络交通拥堵时，会控制自己发送片段的速率，以缓解网络的交通状况，避免堵塞崩溃。简言之，TCP 协议规定了发送方需要遵守的“公德”。</p>
<p>我们先来说明堵塞是如何探测的。在 TCP 重新发送中，我们已经总结了两种推测 TCP 片段丢失的方法：ACK 超时和重复 ACK。一旦发送方认为 TCP 片段丢失，则认为网络中出现堵塞。</p>
<p>另一方面，TCP 发送方是如何控制发送速率呢？TCP 协议通过控制滑窗(sliding window)大小来控制发送速率。在 TCP 滑窗管理中，我们已经见到了一个窗口限制，就是advertised window size，以实现 TCP 流量控制。TCP 还会维护一个congestion window size，以根据网络状况来调整滑窗大小。真实滑窗大小取这两个滑窗限制的最小值，从而同时满足两个限制 (流量控制和堵塞控制)</p>
<p><strong>Congestion Window</strong></p>
<p>congestion window 总是处于两种状态的一个。这两种状态是: 慢起动(slow start)和堵塞避免(congestion avoidance)。</p>
<p><img src="/images/14551396186893.jpg" alt=""></p>
<p>上图是概念性的。实际的实施要比上图复杂，而且根据算法不同会有不同的版本。cwnd 代表congestion window size。我们以片段的个数为单位，来表示 cwnd 的大小 (同样是概念性的)。</p>
<p>Congestion window 从 slow start的状态开始。Slow start 的特点是初始速率低，但速率不断倍增。每次进入到 slow start 状态时，cwnd 都需要重置为初始值 1。发送方每接收到一个正确的 ACK，就会将 congestion window 增加 1，从而实现速率的倍增(由于累计 ACK，速率增长可能会小于倍增)。</p>
<p>当 congestion window 的大小达到某个阈值 ssthresh 时，congestion 进入到 congestion avoidance 状态。发送速率会继续增长。发送方在每个窗户所有片段成功传输后，将窗口尺寸增加 1(实际上就是每个 RTT 增加 1)。所以在 congestion avoidance 下，cwnd 线性增长，增长速率慢。</p>
<p>如果在 congestion avoidance 下有片段丢失，重新回到 slow start 状态，并将 ssthresh 更新为 cwnd 的一半。</p>
<p>我们看到，sshthresh 是 slow start 到 congestion avoidance 的切换点。而片段丢失是 congestion avoidance 到 slow start 的切换点。一开始 sshthresh 的值一般比较大，所以 slow start 可能在切换成 congestion avoidance 之前就丢失片段。这种情况下，slow start 会重新开始，而 ssthresh 更新为 cwnd 的一半。</p>
<p>总的来说，发送速率总是在增长。如果片段丢失，则重置速率为1，并快速增长。增长到一定程度，则进入到慢性增长。快速增长和慢性增长的切换点(sshthred)会随着网络状况(何时出现片段丢失)更新。通过上面的机制，让发送速率处于动态平衡，不断的尝试更大值。初始时增长块，而接近饱和时增长慢。但一旦尝试过度，则迅速重置，以免造成网络负担。</p>
<p>阻塞控制有效的提高了互联网的利用率。阻塞控制的算法多种多样，并且依然不完善。一个常见的问题是cwnd在接近饱和时线性增长，因此对新增的网络带宽不敏感。</p>
<p>互联网利用“公德”来实现效率。“公德”和效率似乎可以并存。</p>
<p>到现在为止，TCP协议的介绍就可以告一段落了。可以回想一下TCP的几大模块：分段与流，滑窗，连接，流量控制，重新发送，堵塞控制。</p>
<h2 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h2><h3 id="DNS协议"><a href="#DNS协议" class="headerlink" title="DNS协议"></a>DNS协议</h3><p>域名(domain name)是IP地址的代号。域名通常是由字符构成的。对于人类来说，字符构成的域名，比如 www.yahoo.com，要比纯粹数字构成的IP地址(106.10.170.118)容易记忆。域名解析系统(DNS, domain name system)就负责将域名翻译为对应的IP地址。在 DNS 的帮助下，我们可以在浏览器的地址栏输入域名，而不是IP地址。这大大减轻了互联网用户的记忆负担。另一方面，处于维护和运营的原因，一些网站可能会变更 IP 地址。这些网站可以更改 DNS 中的对应关系，从而保持域名不变，而 IP 地址更新。由于大部分用户记录的都是域名，这样就可以降低 IP 变更带来的影响。</p>
<p>从机器和技术的角度上来说，域名并不是必须的。但 Internet 是由机器和用户共同构成的。鉴于 DNS 对用户的巨大帮助，DNS 已经被当作 TCP/IP 套装不可或缺的一个组成部分。</p>
<p>域名和 IP 地址的对应关系存储在 DNS 服务器(DNS server)中。所谓的 DNS 服务器，是指在网络中进行域名解析的一些服务器(计算机)。这些服务器都有自己的 IP 地址，并使用 DNS 协议(DNS protocol)进行通信。DNS 协议主要基于 UDP，是应用层协议。</p>
<p><img src="/images/14551396313267.jpg" alt=""></p>
<p>DNS 服务器构成一个分级(hierarchical)的树状体系。上图中，每个节点(node)为一个 DNS 服务器，每个节点都有自己的 IP 地址。树的顶端为用户电脑出口处的 DNS 服务器。在 Linux 下，可以使用 <code>cat /etc/resolv.conf</code>，在 Windows 下，可以使用 <code>ipconfig /all</code>，来查询出口 DNS 服务器。树的末端是真正的域名/IP对应关系记录。一次 DNS 查询就是从树的顶端节点出发，最终找到相应末端记录的过程。</p>
<p>中间节点根据域名的构成，将 DNS 查询引导向下一级的服务器。比如说一个域名 cs.berkeley.edu，DNS解析会将域名分割为 cs, berkeley, edu，然后按照相反的顺序查询(edu, berkeley, cs)。出口 DNS 首先根据 edu，将查询指向下一层的 edu 节点。然后 edu 节点根据 berkeley，将查询指向下一层的 berkeley 节点。这台 berkeley 服务器上存储有 cs.berkeley.edu 的 IP 地址。所以，中间节点不断重新定向，并将我们引导到正确的记录。</p>
<p>在整个 DNS 查询过程中，无论是重新定向还是最终取得对应关系，都是用户计算机和 DNS 服务器使用 DNS 协议通信。用户计算机根据 DNS 服务器的反馈，依次与下一层的 DNS 服务器建立通信。用户计算机经过递归查询，最终和末端节点通信，并获得IP地址。</p>
<p><img src="/images/14551396446583.jpg" alt=""></p>
<p>用户计算机的操作系统中的域名解析模块(DNS Resolver)负责域名解析的相关工作。任何一个应用程序(邮件，浏览器)都可以通过调用该模块来进行域名解析。</p>
<p>并不是每次域名解析都要完整的经历解析过程。DNS Resolver 通常有 DNS 缓存(cache)，用来记录最近使用和查询的域名/IP关系。在进行 DNS 查询之前，计算机会先查询 cache 中是否有相关记录。这样，重复使用的域名就不用总要经过整个递归查询过程。</p>
<p><img src="/images/14551396560030.jpg" alt=""></p>
<p>上面的DNS查询均为正向DNS查询：已经知道域名，想要查询对应 IP。而反向 DNS(reverse DNS)是已经知道IP的前提下，想要查询域名。反向 DNS 也是采用分层查询方式，对于一个 IP 地址(比如106.10.170.118)，依次查询in-addr.arpa节点(如果是IPv6，则为ip6.arpa节点)，106节点，10节点，170节点，并在该节点获得 106.10.170.118 对应的域名。</p>
<h3 id="HTTP协议概览"><a href="#HTTP协议概览" class="headerlink" title="HTTP协议概览"></a>HTTP协议概览</h3><p>我在 TCP 流通信中说明了，TCP 协议实现了数据流的传输。然而，人们更加习惯以文件为单位传输资源，比如文本文件，图像文件，超文本文档(hypertext document)。</p>
<p>超文本文档中包含有超链接，指向其他的资源。超文本文档是万维网(World Wide Web，即www)的基础。</p>
<p>HTTP 协议解决文件传输的问题。HTTP 是应用层协议，主要建立在 TCP 协议之上(偶尔也可以 UDP 为底层)。它随着万维网的发展而流行。HTTP 协议目的是，如何在万维网的网络环境下，更好的利用 TCP 协议，以实现文件，特别是超文本文件的传输。</p>
<p>早期的 HTTP 协议主要传输静态文件，即真实存储在服务器上的文件。随着万维网的发展，HTTP 协议被用于传输“动态文件”，服务器上的程序根据 HTTP 请求即时生成的动态文件。我们将 HTT P的传输对象统称为资源(resource)。</p>
<p>HTTP实现了资源的订购和传送。其工作方式类似于快餐点单。</p>
<ol>
<li>请求(request): 顾客向服务员提出请求：“来个鸡腿汉堡”。</li>
<li>回复(response):服务员根据情况，回应顾客的请求</li>
</ol>
<p>根据情况的不同，服务员的回应可能有很多，比如:</p>
<ul>
<li>服务员准备鸡腿汉堡，将鸡腿汉堡交给顾客。（一切OK）</li>
<li>服务员发现自己只是个甜品站。他让顾客前往正式柜台点单。（重新定向）</li>
<li>服务员告诉顾客鸡腿汉堡没有了。(无法找到)</li>
</ul>
<p>交易结束后，服务员就将刚才的交易抛到脑后，准备服务下一位顾客。</p>
<p>HTTP协议的通信是一次 request-responce 交流。客户端(guest)向服务器发出请求(request)，服务器(server)回复(response)客户端。</p>
<p><img src="/images/14551396675029.jpg" alt=""></p>
<p>HTTP协议规定了请求和回复的格式:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">起始行 (start line)</div><div class="line">头信息 (headers)</div><div class="line"></div><div class="line">主体(entity body)</div></pre></td></tr></table></figure>
<p>起始行只有一行。它包含了请求/回复最重要的信息。请求的起始行表示(顾客)“想要什么”。回复的起始行表示(后厨)“发生什么”。</p>
<p>头信息可以有多行。每一行是一对键值对(key-value pair)，比如:</p>
<pre><code>Content-type: text/plain 
</code></pre><p>它表示，包含有一个名为 Content-type 的参数，该参数的值为 text/plain。头信息是对起始行的补充。请求的头信息对服务器有指导意义 (好像在菜单上注明: 鸡腿不要辣)。回复的头信息则是提示客户端（比如，在盒子上注明: 小心烫）</p>
<p>主体部分包含了具体的资源。上图的请求中并没有主体，因为我们只是在下单，而不用管后厨送什么东西 (请求是可以有主体内容的)。回复中包含的主体是一段文本文字(Hello World!)。这段文本文字正是顾客所期待的，鸡腿汉堡。</p>
<p>我们深入一些细节。先来看一下请求:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">GET /index.html HTTP/1.1</div><div class="line">Host: www.example.com</div></pre></td></tr></table></figure>
<p>在起始行中，有三段信息:</p>
<p>GET 方法。用于说明想要服务器执行的操作。<br>/index.html 资源的路径。这里指向服务器上的index.html文件。<br>HTTP/1.1 协议的版本。HTTP第一个广泛使用的版本是1.0，当前版本为1.1。</p>
<p>早期的 HTTP 协议只有 GET 方法。遵从 HTTP 协议，服务器接收到 GET 请求后，会将特定资源传送给客户。这类似于客户点单，并获得汉堡的过程。使用 GET 方法时，是客户向服务器索取资源，所以请求往往没有主体部分。</p>
<p>GET 方法也可以用于传输一些不重要的数据。它是通过改写 URL 的方式实现的。GET 的数据利用 <code>URL?变量名＝变量值</code> 的方法传输。比如向 <a href="http://127.0.0.1" target="_blank" rel="external">http://127.0.0.1</a> 发送一个变量“q”，它的值为“a”。那么，实际的URL为<a href="http://127.0.0.1?q=a。服务器收到请求后，就可以知道&quot;q&quot;的值为&quot;a&quot;。" target="_blank" rel="external">http://127.0.0.1?q=a。服务器收到请求后，就可以知道&quot;q&quot;的值为&quot;a&quot;。</a></p>
<p>GET 方法之外，最常用的是 POST 方法。它用于从客户端向服务器提交数据。使用 POST 方法时，URL 不再被改写。数据位于 http 请求的主体。POST 方法最用于提交 HTML 的 form 数据。服务器往往会对 POST 方法提交的数据进行一定的处理，比如存入服务器数据库。</p>
<p>样例请求中有一行头信息。该头信息的名字是 Host。HTTP 的请求必须有 Host 头信息，用于说明服务器的地址和端口。HTTP 协议的默认端口是 80，如果在 HOST 中没有说明端口，那么将默认采取该端口。在该例子中，服务器的域名为 www.example.com，端口为 80。域名将通过 DNS 服务器转换为 IP 地址，从而确定服务器在互联网上的地址。</p>
<p>服务器在接收到请求之后，会根据程序，生成对应于该请求的回复，比如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">HTTP/1.1 200 OK</div><div class="line">Content-type: text/plain</div><div class="line">Content-length: 12</div><div class="line"></div><div class="line">Hello World!</div></pre></td></tr></table></figure>
<p>回复的起始行同样包含三段信息</p>
<ul>
<li>HTTP/1.1 协议版本</li>
<li>200 状态码(status code)。</li>
<li>OK 状态描述</li>
</ul>
<p>OK 是对状态码 20 0的文字描述，它只是为了便于人类的阅读。电脑只关心三位的状态码(status code)，即这里的 200。200 表示一切 OK，资源正常返回。状态码代表了服务器回应动作的类型。</p>
<p>其它常见的状态码还有:</p>
<ul>
<li>302，重新定向(redirect): 我这里没有你想要的资源，但我知道另一个地方xxx有，你可以去那里找。</li>
<li>404，无法找到(not found): 我找不到你想要的资源，无能为力。</li>
</ul>
<p>(重新定向时，客户端可以根据302的建议前往xxx寻找资源，也可以忽略该建议。)</p>
<p>Content-type 说明了主体所包含的资源的类型。根据类型的不同，客户端可以启动不同的处理程序(比如显示图像文件，播放声音文件等等)。下面是一些常见的资源</p>
<ul>
<li>text/plain 普通文本</li>
<li>text/html HTML 文本</li>
<li>image/jpeg jpeg 图片</li>
<li>image/gif gif 图片</li>
<li>Content-length 说明了主体部分的长度，以字节(byte)为单位。</li>
</ul>
<p>回应的主体部分为一段普通文本，即</p>
<pre><code>Hello World!
</code></pre><p>根据早期的 HTTP 协议，每次 request-reponse 时，都要重新建立 TCP 连接。TCP 连接每次都重新建立，所以服务器无法知道上次请求和本次请求是否来自于同一个客户端。因此，HTTP 通信是无状态(stateless)的。服务器认为每次请求都是一个全新的请求，无论该请求是否来自同一地址。</p>
<p>想象高级餐厅和快餐店。高级餐厅会知道客人所在的位置，如果新增点单，那么服务员知道这和上一单同一桌。而在快餐店中，不好意思，服务员并不记录客人的特征。想再次点单？请重新排队……</p>
<p>随着 HTTP 协议的发展，HTTP 协议允许 TCP 连接复用，以节省建立连接所耗费的时间。但HTTP协议依然保持无状态的特性。</p>
<h2 id="综合"><a href="#综合" class="headerlink" title="综合"></a>综合</h2><h3 id="CIDR-与-NAT"><a href="#CIDR-与-NAT" class="headerlink" title="CIDR 与 NAT"></a>CIDR 与 NAT</h3><p>IPv4 由于最初的设计原因，长度只有 32 位，所以只提供了大约 40 亿个地址。这造成了 IPv4 地址的耗尽危机。随后，IPv6 被设计出来，并可以提供足够多的 IP 地址。但是 IPv4 与 IPv6 并不兼容，IPv4 向 IPv6 的迁移并不容易。一些技术，比如说这里要说的 CIDR 和 NAT，相继推广。这些技术可以缓解 IPv4 的稀缺状态，成就了 IPv4 一时的逆袭。</p>
<p>CIDR(Classless Inter Domain Routing)改进了传统的 IPv4 地址分类。传统的 IP 分类将 IP 地址直接对应为默认的分类，从而将 Internet 分割为网络。CIDR 在路由表中增加了子网掩码(subnet masking)，从而可以更细分网络。利用 CIDR，我们可以灵活的将某个范围的IP地址分配给某个网络。</p>
<p>1) IP地址分类</p>
<p>在IP接力赛中，我提到，IP地址可以分为如下几类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">IP class    From          To                 Subnet Mask</div><div class="line">A           1.0.0.0       126.255.255.255    255.0.0.0</div><div class="line">B           128.0.0.0     191.255.255.255    255.255.0.0</div><div class="line">C           192.0.0.0     223.255.255.255    255.255.255.0</div></pre></td></tr></table></figure>
<p>这是最初的IPv4地址分类设计。一个IPv4地址总共有32位，可以分为网络(network)和主机(host)两部分。子网掩码(subnet mask)是用于表示哪些位代表了网络部分。比如如下 subnet mask 255.0.0.0的二进制表示为：</p>
<p>11111111 00000000 00000000 00000000</p>
<p>它的前八位为 1，所以表示IP地址的前八位为网络部分。而后面的 24 位代指该网络的各个主机。一个 A 类网络可以有 224 台主机，也就是 16777216。由于 IPv4 地址已经分好了类，所以当我们拿到一个 IP 地址，我们就可以通过上面查到它的子网掩码。(B类，216; C类，28)</p>
<p>2) 传统路由表</p>
<p>IP分类的方便了IP包的接力。IP包到达某个路由器后，会根据该路由器的路由表(routing table)，来决定接力的下一站。一个传统的路由表看起来是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Destination        Gateway             Iface</div><div class="line">199.165.145.0      0.0.0.0             eth0</div><div class="line">199.165.146.0      0.0.0.0             eth1</div><div class="line">0.0.0.0            199.165.146.8       eth1</div></pre></td></tr></table></figure>
<p>该路由表代表的网络拓扑如下：</p>
<p><img src="/images/14551396849165.jpg" alt=""></p>
<p>由于 IP 分类，我们不需要记录 subnet mask。当我们要前往 199.165.146.17 时，我们已经知道这台主机位于一个 C 类地址，所以它的子网掩码是 255.255.255.0，也就是说 199.165.146 代表了网络，17 代表了主机。</p>
<p>3) CIDR 路由表</p>
<p>然而，由于默认分类，造成了网络只能按照 A、B、C 的方式存在。假设一个网络(比如 MIT 的网络)分配了一个 A 类地址，那么该网络将容许 16777216 个主机。如果该网络无法用完这些 IP 地址，这些 IP 地址将无法被其他网络使用。再比如上面的网络，199.165.145 必须作为一个整个的网络存在。如果我们只有 10 台主机，那么将会有 200 多个 IP 地址被浪费。CIDR 的本质是在路由表中加入子网掩码，并根据该列信息对网络进行分割，而不是根据默认的 A，B，C 进行分割。比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Destination        Gateway             Genmask             Iface</div><div class="line">199.165.145.254    0.0.0.0             255.255.255.254     eth2</div><div class="line">199.165.145.0      0.0.0.0             255.255.255.0       eth0</div><div class="line">199.165.146.0      0.0.0.0             255.255.255.0       eth1</div><div class="line">0.0.0.0            199.165.146.8       0.0.0.0             eth1</div></pre></td></tr></table></figure>
<p>根据路由表的第一条记录，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">199.165.145.254 (IP address) : 11000111 10100101 10010001 11111110</div><div class="line">255.255.255.254 (subnet mask): 11111111 11111111 11111111 11111110 (31个1，1个0)</div></pre></td></tr></table></figure>
<p>通过子网掩码可以知道，前 31 位表示网络，最后一位表示主机。子网掩码总是有连续多个 1 组成，比如上面的 31 个 1。所以也可记为 199.165.145.254/31，来同时表示 IP 地址和子网掩码。</p>
<p>路由器将原来的 199.165.145 网络中的一部分分割出来。这一网络可以容纳两台电脑，也就是 199.165.145.254 和 199.165.145.255。这个网络对应网卡是 eth2。当有 IP 包通向这两个 IP 地址时，会前往 eth2，而不是 eth0。</p>
<p>网络拓扑如下：</p>
<p><img src="/images/14551396962662.jpg" alt=""></p>
<p>利用 CIDR，我们可以将 IP 地址根据需要进行分割，从而不浪费 IP 地址。</p>
<p>CIDR 虽然可以更加节约 IP 地址，但它并不能创造新的 IP 地址。IP 地址的耗尽危机并不能因此得到解决。我们来看 IPv4 的第二袭，NAT(Network Address Translation)。</p>
<p>理论上，每个 IP 地址代表了 Internet 上的一个设备。但有一些 IP 地址被保留，用于一些特殊用途。下面三段IP地址被保留用作私有 IP 地址：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">From          To             </div><div class="line">10.0.0.0      10.255.255.255</div><div class="line">172.16.0.0    172.31.255.255</div><div class="line">192.168.0.0   192.168.255.255</div></pre></td></tr></table></figure>
<p>私有 IP 地址只用于局域网内部。理论上，我们不应该在互联网上看到来自或者发往私有 IP 地址的 IP 包。与私有 IP 地址对应的是全球 IP 地址(global IP address)。</p>
<p>NAT 是为私有网络(private network)服务的。该网络中的主机使用私有IP地址。当私有网络内部主机和外部 Internet 通信时，网关(gateway)路由器负责将私有 IP 地址转换为全球 IP 地址，这个地址转换过程就是 Network Address Translation。网关路由器的 NAT 功能。最极端情况下，我们可以只分配一个全球 IP 地址给网关路由器，而私有网络中的设备都使用私有 IP 地址。由于私有 IP 地址可以在不同私有网络中重复使用，所以就大大减小了设备对 IP 地址的需求。</p>
<p>1) 基础 NAT</p>
<p>NAT 的一种为基础 NAT，也成为一对一(one-to-one)NAT。在基础 NAT 下，网关路由器一一转换一个外部 IP 地址和一个私有 IP 地址。网关路由器保存有 IP 的 NAT 对应关系，比如：</p>
<p><img src="/images/14551397079720.jpg" alt=""></p>
<p>上面网络中，当有 IP 包要前往 199.165.145.1 时，网关路由器会将目的地改写为 10.0.0.1，并接力给私有网络中的 10.0.0.1 的电脑。同样，当 10.0.0.1 的电脑向 Internet 发送 IP 包时，它的发送地为 10.0.0.1。在到达网关路由器时，会将发送地更改为 199.165.145.1。此外，IP 头部的 checksum，以及更高层协议(比如 UDP 和 TCP)中的校验 IP 的 checksum 也会更改。</p>
<p>基础 NAT 尽管是一对一转换 IP 地址，它还是可以减小内部网络对 IP 地址的需求。通常来说，一个局域网中只有少数的设备处于开机状态，并不需要给每个设备对应一个全球 IP 地址。NAT 可以动态的管理全球 IP 地址，并将全球 IP 地址对应到开机设备，从而减小内部网络对 IP 地址的需求。</p>
<p>2) NAPT</p>
<p>NAT 还有一种，被成为 NAPT (Network Address and Port Translation)。在基础 NAT 中，高层协议的端口号并不会改动。NAPT 下，IP 地址和端口号可能同时改动。</p>
<p>我们在 UDP 和 TCP 中提到端口(port)的概念。在建立 UDP 或者 TCP 通信时，我们实际上是用 IP:Port 来代表通信的一端(正如打电话时主机:分机号一样)。NAPT 就是在网关路由器处建立两个通信通道，一个通往内部网络，一个通往外部网络，然后将网关处的通道端口连接，从而让内部和外部通信。比如：</p>
<p><img src="/images/14551397204458.jpg" alt=""></p>
<p>我们看到，通往 IP 199.165.145.1 建立了三个端口的连接：8888, 8889 和 8080。它们分别在 NAPT 处改为通往 10.0.0.1:80, 10.0.0.1:8080 和 10.0.0.3:6000。NAPT 记录有 外部IP:端口 和 内部IP:端口 的一一对应关系。在 IP 包经过时，网关路由器会更改 IP 地址，端口号以及相关的 checksum。</p>
<p>利用 NAPT 我们可以使用一个(或者多个但少量的)外部 IP 和大量的端口号，来对应多个内部 IP 以及相应的端口号，从而大大减小了对全球 IP 地址的需求。</p>
<p>无论是基础 NAT 还是 NAPT，它们的设置都比较复杂，并且从本质上违背了互联网最初的设计理念。但由于 IPv4 的使用惯性，NAT 还是被广泛推广。由于 NAT 所处的网关服务器是理想的设置防火墙的位置，NAT 还往往和防火墙共同建设，以提高私有网络的安全性。</p>
<p>即使是 CIDR 和 NAT 广泛使用，IPv4 还是在不可避免的耗尽。IPv6 正在加紧部署。但上述的两种技术，CIDR 和 NAT 在 IPv6 中同样被采用，所以了解它们依然是有意义的。</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>下面是一些Mac OS X下常用的网络诊断命令。它们能帮助我们发现网络问题。有些工具，如 <code>arping</code>, <code>arp-scan</code>，需要借助 HomeBrew 安装。</p>
<p>网络诊断的第一步，是了解自己的设备，比如有哪些接口，IP地址都是什么。</p>
<pre><code># 显示网络接口(interface)信息
# 如接口名称，接口类型，接口的 IP 地址，硬件的 MAC 地址等。
ifconfig
</code></pre><p>ARP 协议用在局域网(LAN)内部。借用 ARP 协议，设备可以知道同一局域网内的 IP-MAC 对应关系。当我们访问一个本地 IP 地址时，设备根据该对应关系，与对应的 MAC 地址通信。通过 ARP 工具，我们可以知道局域网内的通信是否正常。</p>
<pre><code># 显示本地存储的 IP-MAC 对应关系
arp -a

# 经 eth0 接口，发送 ARP 请求，查询 IP 为 192.168.1.1 设备的 MAC 地址
sudo arping -I eth0 192.168.1.1

# 查询整个局域网内的所有IP地址的对应 MAC 地址
sudo arp-scan -l

# 监听 en0 接口的 arp 协议通信
sudo tcpdump -i en0 arp
</code></pre><p>网络层是一个广域的互联网，互联网上的设备用 IP 地址识别。ping 是向某个 IP 地址发送 ICMP 协议的 <code>ECHO_REQUEST</code> 请求。收到该请求的设备，将返回 ICMP 回复。如果 ping 到某个 IP 地址，那么说明该IP地址的设备可以经网络层顺利到达。</p>
<pre><code># 向 IP 地址 192.168.1.255 发送 ICMP 请求
# 如果该地址的 ICMP 没有被禁用，那么在该网上的设备将回复。
ping 192.168.1.1

# 向广播(broadcast)地址 192.168.1.255 发送 ICMP 请求
# 如果 ICMP 没有被禁用，那么在该网上的设备将回复
# 需要注意的是，许多设备会禁用 ICMP
# 如果 ping 不到一个设备，并不一定是网络层故障。
ping 192.168.1.255
</code></pre><p>如果两个设备有相同的 IP 地址，将导致 IP 冲突。许多网络中是由 DHCP 协议自动分配 IP 地址的，这样可以极大的减少 IP 冲突的可能性。DHCP 服务器与设备达成协议，设备将在一定时间内占据某个 IP 地址，而 DHCP 服务器不再把该 IP 地址分配给别人。</p>
<pre><code>sudo ipconfig set en0 DHCP
更新 DHCP 租约。设备将释放 IP 地址，再从 DHCP 服务器重新获得 IP 地址。

sudo ipconfig set en0 INFORM 192.168.0.120
将接口 en0 设定为静态 IP 地址。
</code></pre><p>局域网通过路由器，接入广域的互联网。互联网上的通信往往要经过多个路由器接力。途中路由器的故障，可能导致互联网访问异常。</p>
<pre><code># 显示路由表。从路由表中，可以找到网关(Gateway)
# 网关是通向更加广域网络的出口
netstat -nr

# 追踪到达IP目的地的全程路由
traceroute 74.125.128.99

# 通过ICMP协议，追踪路由
# ICMP协议经常会被禁用，所以会返回&quot;*&quot;的字符串。
traceroute -I 74.125.128.99

# 通过TCP协议，经80端口，追踪路由
# TCP协议的默认端口80很少会被禁用
sudo traceroute -T -p 80 74.125.128.99
</code></pre><p>tcpdump 是一款网络抓包工具。它可以监听网络接口不同层的通信，并过滤出特定的内容，比如特定协议、特定端口等等。我们上面已经使用 tcpdump 监听了 ARP 协议通信。这里我们来看更多的监听方式。</p>
<pre><code># 监听en0接口的所有通信
sudo tcpdump -i en0

# 用ASCII显示en0接口的通信内容
sudo tcpdump -A -i en0 

# 显示en0接口的8080端口的通信
sudo tcpdump -i en0 &apos;port 8080&apos;

# 显示eth1接口，来自192.168.1.200的通信
sudo tcpdump -i eth1 src 192.168.1.200

# 显示eth1接口80端口，目的地为192.168.1.101的通信
sudo tcpdump -i eth1 dst 192.168.1.101 and port 80

# 将lo0接口的通信存入文件record.pcap
sudo tcpdump -w record.pcap -i lo0
</code></pre><p>DNS是在域名和IP之间进行翻译。DNS故障会导致我们无法通过域名访问某个网址。 </p>
<pre><code># DNS域名解析。返回域名对应的IP地址
host www.sina.com.cn
</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.cnblogs.com/vamei/" target="_blank" rel="external">Vamei</a></li>
<li><a href="http://www.cnblogs.com/maybe2030/" target="_blank" rel="external">Poll 的笔记</a></li>
</ul>

    
  </div>


          </div>
          

  <p>热评文章</p>
  <div class="ds-top-threads" data-range="weekly" data-num-items="4"></div>


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="vault/internet-protocol.html"
           data-title="计算机网络" data-url="http://wdxtub.com/vault/internet-protocol.html">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/misc/avatar.jpg"
               alt="wdxtub" />
          <p class="site-author-name" itemprop="name">wdxtub</p>
          <p class="site-description motion-element" itemprop="description">人文/科学/读书/写作/思考/编程/架构/数据/广交朋友/@SYSU/@CMU</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">710</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">874</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/wdxtub" target="_blank" title="GitHub">
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/wdxtub" target="_blank" title="微博">
                  
                  微博
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://douban.com/people/wdx" target="_blank" title="豆瓣">
                  
                  豆瓣
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/wdxtub" target="_blank" title="知乎">
                  
                  知乎
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              不妨看看
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://zhchbin.github.io/" title="zhchbin" target="_blank">zhchbin</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.algorithmdog.com/" title="算法狗" target="_blank">算法狗</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.52cs.org/" title="我爱计算机" target="_blank">我爱计算机</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://jackqdyulei.github.io/" title="雷雷" target="_blank">雷雷</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://guojiex.github.io/" title="瓜瓜" target="_blank">瓜瓜</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://wdxtub.lofter.com/" title="我的 Lofter" target="_blank">我的 Lofter</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://wdxtub.com/interview/" title="刷题笔记" target="_blank">刷题笔记</a>
                </li>
              
            </ul>
          </div>
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2013 - 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wdxtub</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

<div class="busuanzi-count">

  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv"><i class="fa fa-user"></i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span>
  

  
    <span class="site-pv"><i class="fa fa-eye"></i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span>
  
  
</div>



        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"wdxblog"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementById('footer')
      || document.getElementById('footer')).appendChild(ds);
    })();
  </script>

  
    
      
      <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
      <script src="/js/src/hook-duoshuo.js"></script>
    
  





  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
       search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();

    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
    'use strict';
    $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
            // get the contents from search data
            isfetched = true;
            $('.popup').detach().appendTo('.header-inner');
            var datas = $( "entry", xmlResponse ).map(function() {
                return {
                    title: $( "title", this ).text(),
                    content: $("content",this).text(),
                    url: $( "url" , this).text()
                };
            }).get();
            var $input = document.getElementById(search_id);
            var $resultContent = document.getElementById(content_id);
            $input.addEventListener('input', function(){
                var matchcounts = 0;
                var str='<ul class=\"search-result-list\">';                
                var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                $resultContent.innerHTML = "";
                if (this.value.trim().length > 1) {
                // perform local searching
                datas.forEach(function(data) {
                    var isMatch = true;
                    var content_index = [];
                    var data_title = data.title.trim().toLowerCase();
                    var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                    var data_url = data.url;
                    var index_title = -1;
                    var index_content = -1;
                    var first_occur = -1;
                    // only match artiles with not empty titles and contents
                    if(data_title != '' && data_content != '') {
                        keywords.forEach(function(keyword, i) {
                            index_title = data_title.indexOf(keyword);
                            index_content = data_content.indexOf(keyword);
                            if( index_title < 0 && index_content < 0 ){
                                isMatch = false;
                            } else {
                                if (index_content < 0) {
                                    index_content = 0;
                                }
                                if (i == 0) {
                                    first_occur = index_content;
                                }
                            }
                        });
                    }
                    // show search results
                    if (isMatch) {
                        matchcounts += 1;
                        str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                        var content = data.content.trim().replace(/<[^>]+>/g,"");
                        if (first_occur >= 0) {
                            // cut out 100 characters
                            var start = first_occur - 20;
                            var end = first_occur + 80;
                            if(start < 0){
                                start = 0;
                            }
                            if(start == 0){
                                end = 50;
                            }
                            if(end > content.length){
                                end = content.length;
                            }
                            var match_content = content.substring(start, end);
                            // highlight all keywords
                            keywords.forEach(function(keyword){
                                var regS = new RegExp(keyword, "gi");
                                match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                            });
                            
                            str += "<p class=\"search-result\">" + match_content +"...</p>"
                        }
                        str += "</li>";
                    }
                })};
                str += "</ul>";
                if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
                if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
                $resultContent.innerHTML = str;
            });
            proceedsearch();
        }
    });}

    // handle and trigger popup window;
    $('.popup-trigger').mousedown(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };

    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>

  
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
  </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script>
  <script type="text/javascript" src=""></script>


  

  
<script type="text/javascript" async src="//push.zhanzhang.baidu.com/push.js">
</script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->


</body>
</html>
